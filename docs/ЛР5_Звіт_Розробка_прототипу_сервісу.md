# Лабораторна робота №5
# Розробка прототипу сервісу

**Предметна область:** Система управління проєктами TaskFlow

**Виконав:** Студент групи ІСП

**Дата:** 18 грудня 2025 року

---

## Зміст

1. [Мета роботи](#мета-роботи)
2. [Завдання](#завдання)
3. [Теоретичні відомості](#теоретичні-відомості)
4. [Опис мікросервісу Projects Service](#опис-мікросервісу-projects-service)
5. [Структура проєкту](#структура-проєкту)
6. [Схема бази даних](#схема-бази-даних)
7. [Реалізація REST API](#реалізація-rest-api)
8. [Контейнеризація з Docker](#контейнеризація-з-docker)
9. [Тестування API](#тестування-api)
10. [Висновки](#висновки)

---

## Мета роботи

Метою лабораторної роботи є розробка прототипу мікросервісу з REST API, реалізація CRUD операцій для роботи з даними, налаштування підключення до бази даних PostgreSQL та контейнеризація сервісу за допомогою Docker.

---

## Завдання

1. Обрати один із мікросервісів системи TaskFlow для реалізації прототипу
2. Розробити REST API з повним набором CRUD операцій
3. Реалізувати підключення до бази даних PostgreSQL
4. Створити схему бази даних з необхідними таблицями та індексами
5. Реалізувати контролери та маршрути для обробки HTTP запитів
6. Створити Dockerfile для контейнеризації сервісу
7. Налаштувати docker-compose.yml для оркестрації сервісу та бази даних
8. Протестувати API за допомогою Postman
9. Задокументувати всі endpoint'и та формати запитів/відповідей

---

## Теоретичні відомості

### REST API

REST (Representational State Transfer) - архітектурний стиль для розробки веб-сервісів, що базується на використанні HTTP протоколу та його методів:

- **GET** - отримання ресурсу або колекції ресурсів
- **POST** - створення нового ресурсу
- **PUT/PATCH** - оновлення існуючого ресурсу
- **DELETE** - видалення ресурсу

Основні принципи REST:
- Stateless (без стану) - кожен запит містить всю необхідну інформацію
- Client-Server - розділення відповідальності між клієнтом та сервером
- Cacheable - відповіді можуть кешуватися
- Uniform Interface - єдиний інтерфейс взаємодії

### CRUD операції

CRUD - базовий набір операцій для роботи з даними:
- **Create** (Створити) - POST запит
- **Read** (Прочитати) - GET запит
- **Update** (Оновити) - PUT/PATCH запит
- **Delete** (Видалити) - DELETE запит

### PostgreSQL

PostgreSQL - об'єктно-реляційна система управління базами даних з підтримкою ACID транзакцій, складних запитів, тригерів, представлень та процедур. Основні переваги:
- Висока надійність та відповідність стандартам SQL
- Підтримка JSON та повнотекстового пошуку
- Розширюваність та масштабованість
- Підтримка індексів для оптимізації запитів

### Docker

Docker - платформа для контейнеризації застосунків, що дозволяє:
- Ізолювати застосунки та їх залежності
- Забезпечити однакове середовище на різних машинах
- Спростити розгортання та масштабування
- Оркеструвати кілька контейнерів за допомогою Docker Compose

---

## Опис мікросервісу Projects Service

Для реалізації прототипу було обрано мікросервіс **Projects Service**, який є ключовим компонентом системи TaskFlow та відповідає за управління проєктами.

### Функціональні можливості

Projects Service надає наступний функціонал:

1. **Управління проєктами:**
   - Створення нових проєктів
   - Перегляд списку проєктів з фільтрацією та пагінацією
   - Отримання детальної інформації про проєкт
   - Оновлення параметрів проєкту
   - Видалення проєктів

2. **Управління учасниками:**
   - Додавання учасників до проєкту
   - Призначення ролей учасникам
   - Видалення учасників з проєкту

3. **Фільтрація та пошук:**
   - Фільтрація за власником проєкту
   - Фільтрація за статусом
   - Пагінація результатів

### Технологічний стек

- **Runtime:** Node.js 20
- **Мова програмування:** TypeScript
- **Web-фреймворк:** Express.js
- **База даних:** PostgreSQL 16
- **ORM/Database driver:** pg (node-postgres)
- **Контейнеризація:** Docker + Docker Compose

---

## Структура проєкту

Проєкт організовано за модульним принципом з розділенням відповідальності:

```
projects-service/
├── src/
│   ├── config/
│   │   └── database.ts          # Конфігурація підключення до БД
│   ├── controllers/
│   │   └── project.controller.ts # Бізнес-логіка обробки запитів
│   ├── models/
│   │   └── project.model.ts      # Типи та інтерфейси даних
│   ├── routes/
│   │   └── project.routes.ts     # Визначення маршрутів API
│   ├── middleware/
│   │   └── errorHandler.ts       # Обробка помилок
│   ├── app.ts                    # Налаштування Express застосунку
│   └── server.ts                 # Точка входу
├── package.json                  # Залежності проєкту
├── tsconfig.json                 # Конфігурація TypeScript
├── Dockerfile                    # Інструкції для збірки образу
├── docker-compose.yml            # Оркестрація контейнерів
├── .env.example                  # Приклад змінних середовища
└── README.md                     # Документація проєкту
```

### Опис ключових файлів

#### database.ts
Відповідає за підключення до PostgreSQL, виконання запитів та ініціалізацію схеми бази даних. Використовує пул з'єднань для ефективного використання ресурсів.

#### project.controller.ts
Містить клас `ProjectController` з методами для обробки всіх CRUD операцій. Кожен метод приймає об'єкти Request та Response з Express.

#### project.routes.ts
Визначає маршрути API та зв'язує їх з відповідними методами контролера.

#### app.ts
Налаштовує Express застосунок: підключає middleware (CORS, JSON parser, логер), реєструє маршрути та обробники помилок.

#### server.ts
Ініціалізує базу даних та запускає HTTP сервер на вказаному порту.

---

## Схема бази даних

### Таблиця `projects`

Основна таблиця для зберігання інформації про проєкти.

```sql
CREATE TABLE projects (
  id SERIAL PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  description TEXT,
  owner_id INTEGER NOT NULL,
  status VARCHAR(50) DEFAULT 'active',
  start_date DATE,
  end_date DATE,
  deadline DATE,
  priority VARCHAR(20) DEFAULT 'medium',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Поля:**
- `id` - унікальний ідентифікатор проєкту (автоінкремент)
- `name` - назва проєкту (обов'язкове поле)
- `description` - опис проєкту
- `owner_id` - ідентифікатор власника проєкту
- `status` - статус проєкту (active, completed, archived, on_hold)
- `start_date` - дата початку проєкту
- `end_date` - фактична дата завершення
- `deadline` - планова дата завершення
- `priority` - пріоритет (low, medium, high, critical)
- `created_at` - дата створення запису
- `updated_at` - дата останнього оновлення

### Таблиця `project_members`

Зберігає інформацію про учасників проєктів та їх ролі.

```sql
CREATE TABLE project_members (
  id SERIAL PRIMARY KEY,
  project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  user_id INTEGER NOT NULL,
  role VARCHAR(50) NOT NULL,
  joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(project_id, user_id)
);
```

**Поля:**
- `id` - унікальний ідентифікатор запису
- `project_id` - зовнішній ключ на таблицю projects
- `user_id` - ідентифікатор користувача
- `role` - роль у проєкті (owner, manager, developer, designer, tester)
- `joined_at` - дата приєднання до проєкту

**Зв'язки:**
- `project_id` → `projects.id` (ON DELETE CASCADE)
- Унікальне обмеження на пару (project_id, user_id)

### Індекси

Для оптимізації запитів створено наступні індекси:

```sql
CREATE INDEX idx_projects_owner_id ON projects(owner_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_project_members_project_id ON project_members(project_id);
CREATE INDEX idx_project_members_user_id ON project_members(user_id);
```

---

## Реалізація REST API

### Архітектура обробки запитів

```
HTTP Request
    ↓
Express Router (routes/project.routes.ts)
    ↓
Controller Method (controllers/project.controller.ts)
    ↓
Database Query (config/database.ts)
    ↓
PostgreSQL Database
    ↓
Response JSON
```

### API Endpoints

#### 1. Health Check

**Endpoint:** `GET /health`

**Опис:** Перевірка стану сервісу

**Відповідь:**
```json
{
  "success": true,
  "message": "Projects Service is running",
  "timestamp": "2025-12-18T10:30:00.000Z"
}
```

#### 2. Отримати всі проєкти

**Endpoint:** `GET /api/projects`

**Query параметри:**
- `owner_id` (optional) - фільтр за власником
- `status` (optional) - фільтр за статусом
- `limit` (optional, default: 50) - кількість записів
- `offset` (optional, default: 0) - зсув для пагінації

**Приклад запиту:**
```
GET /api/projects?owner_id=1&status=active&limit=10&offset=0
```

**Відповідь:**
```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "name": "TaskFlow Platform Development",
      "description": "Розробка платформи управління проєктами",
      "owner_id": 1,
      "status": "active",
      "priority": "high",
      "start_date": "2025-01-01",
      "deadline": "2025-06-30",
      "created_at": "2025-12-18T10:00:00.000Z",
      "updated_at": "2025-12-18T10:00:00.000Z"
    }
  ],
  "count": 1,
  "limit": 10,
  "offset": 0
}
```

#### 3. Отримати проєкт за ID

**Endpoint:** `GET /api/projects/:id`

**Query параметри:**
- `include_members` (optional) - включити список учасників

**Приклад запиту:**
```
GET /api/projects/1?include_members=true
```

**Відповідь:**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "TaskFlow Platform Development",
    "description": "Розробка платформи управління проєктами",
    "owner_id": 1,
    "status": "active",
    "priority": "high",
    "start_date": "2025-01-01",
    "deadline": "2025-06-30",
    "created_at": "2025-12-18T10:00:00.000Z",
    "updated_at": "2025-12-18T10:00:00.000Z",
    "members": [
      {
        "id": 1,
        "project_id": 1,
        "user_id": 1,
        "role": "owner",
        "joined_at": "2025-12-18T10:00:00.000Z"
      }
    ]
  }
}
```

#### 4. Створити проєкт

**Endpoint:** `POST /api/projects`

**Тіло запиту:**
```json
{
  "name": "New Project",
  "description": "Project description",
  "owner_id": 1,
  "priority": "high",
  "start_date": "2025-01-01",
  "deadline": "2025-12-31"
}
```

**Обов'язкові поля:**
- `name` - назва проєкту
- `owner_id` - ідентифікатор власника

**Відповідь:**
```json
{
  "success": true,
  "message": "Project created successfully",
  "data": {
    "id": 2,
    "name": "New Project",
    "description": "Project description",
    "owner_id": 1,
    "status": "active",
    "priority": "high",
    "start_date": "2025-01-01",
    "deadline": "2025-12-31",
    "created_at": "2025-12-18T10:30:00.000Z",
    "updated_at": "2025-12-18T10:30:00.000Z"
  }
}
```

**Примітка:** При створенні проєкту власник автоматично додається як учасник з роллю "owner".

#### 5. Оновити проєкт

**Endpoint:** `PUT /api/projects/:id`

**Тіло запиту:**
```json
{
  "status": "in_progress",
  "priority": "high",
  "description": "Updated description"
}
```

**Поля для оновлення (всі опціональні):**
- `name` - назва
- `description` - опис
- `status` - статус
- `start_date` - дата початку
- `end_date` - дата завершення
- `deadline` - дедлайн
- `priority` - пріоритет

**Відповідь:**
```json
{
  "success": true,
  "message": "Project updated successfully",
  "data": {
    "id": 1,
    "name": "TaskFlow Platform Development",
    "description": "Updated description",
    "owner_id": 1,
    "status": "in_progress",
    "priority": "high",
    "start_date": "2025-01-01",
    "deadline": "2025-06-30",
    "created_at": "2025-12-18T10:00:00.000Z",
    "updated_at": "2025-12-18T11:00:00.000Z"
  }
}
```

#### 6. Видалити проєкт

**Endpoint:** `DELETE /api/projects/:id`

**Відповідь:**
```json
{
  "success": true,
  "message": "Project deleted successfully"
}
```

**Примітка:** При видаленні проєкту автоматично видаляються всі пов'язані записи з таблиці `project_members` завдяки каскадному видаленню (ON DELETE CASCADE).

#### 7. Додати учасника до проєкту

**Endpoint:** `POST /api/projects/:id/members`

**Тіло запиту:**
```json
{
  "user_id": 2,
  "role": "developer"
}
```

**Відповідь:**
```json
{
  "success": true,
  "message": "Project member added successfully",
  "data": {
    "id": 2,
    "project_id": 1,
    "user_id": 2,
    "role": "developer",
    "joined_at": "2025-12-18T11:30:00.000Z"
  }
}
```

#### 8. Видалити учасника з проєкту

**Endpoint:** `DELETE /api/projects/:id/members/:user_id`

**Відповідь:**
```json
{
  "success": true,
  "message": "Project member removed successfully"
}
```

### Обробка помилок

Всі endpoint'и повертають стандартизовані відповіді з помилками:

**404 Not Found:**
```json
{
  "success": false,
  "message": "Project not found"
}
```

**400 Bad Request:**
```json
{
  "success": false,
  "message": "Name and owner_id are required"
}
```

**500 Internal Server Error:**
```json
{
  "success": false,
  "message": "Internal server error",
  "error": "Detailed error message (only in development)"
}
```

---

## Контейнеризація з Docker

### Dockerfile

Використано multi-stage build для оптимізації розміру образу:

```dockerfile
# Build stage
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY --from=build /app/dist ./dist
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001
USER nodejs
EXPOSE 4002
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:4002/health', ...)"
CMD ["node", "dist/server.js"]
```

**Особливості:**
1. **Multi-stage build** - зменшує розмір фінального образу
2. **Alpine Linux** - мінімалістичний базовий образ
3. **Non-root user** - підвищує безпеку
4. **Health check** - перевіряє стан контейнера
5. **Production dependencies** - встановлюються лише робочі залежності

### Docker Compose

Конфігурація для оркестрації сервісу та бази даних:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: projects-db
    environment:
      POSTGRES_DB: projects_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - projects-network

  projects-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: projects-service
    environment:
      PORT: 4002
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: projects_db
      DB_USER: postgres
      DB_PASSWORD: postgres
      NODE_ENV: production
    ports:
      - "4002:4002"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - projects-network
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local

networks:
  projects-network:
    driver: bridge
```

**Особливості конфігурації:**

1. **Health check для PostgreSQL** - сервіс чекає на готовність БД
2. **Залежність сервісів** - Projects Service запускається після PostgreSQL
3. **Volumes** - дані PostgreSQL зберігаються на хості
4. **Network** - сервіси ізольовані в окремій мережі
5. **Restart policy** - автоматичний перезапуск при збоях

### Команди для запуску

```bash
# Запустити всі сервіси
docker-compose up -d

# Переглянути логи
docker-compose logs -f

# Зупинити сервіси
docker-compose down

# Зупинити з видаленням volumes
docker-compose down -v
```

---

## Тестування API

### Postman колекція

Для тестування API створено Postman колекцію з 8 запитами:

1. **Health Check** - перевірка стану сервісу
2. **Get All Projects** - отримання списку проєктів
3. **Get Project by ID** - отримання проєкту за ID
4. **Create Project** - створення нового проєкту
5. **Update Project** - оновлення проєкту
6. **Delete Project** - видалення проєкту
7. **Add Project Member** - додавання учасника
8. **Remove Project Member** - видалення учасника

### Сценарій тестування

#### Крок 1: Перевірка health check

```
GET http://localhost:4002/health
```

**Очікуваний результат:** Статус 200, сервіс працює

#### Крок 2: Створення проєкту

```
POST http://localhost:4002/api/projects
Content-Type: application/json

{
  "name": "TaskFlow Platform Development",
  "description": "Розробка платформи управління проєктами TaskFlow",
  "owner_id": 1,
  "priority": "high",
  "start_date": "2025-01-01",
  "deadline": "2025-06-30"
}
```

**Очікуваний результат:** Статус 201, проєкт створено з id=1

#### Крок 3: Отримання всіх проєктів

```
GET http://localhost:4002/api/projects
```

**Очікуваний результат:** Статус 200, масив з 1 проєктом

#### Крок 4: Отримання проєкту за ID з учасниками

```
GET http://localhost:4002/api/projects/1?include_members=true
```

**Очікуваний результат:** Статус 200, проєкт з масивом members (1 учасник - owner)

#### Крок 5: Додавання учасника

```
POST http://localhost:4002/api/projects/1/members
Content-Type: application/json

{
  "user_id": 2,
  "role": "developer"
}
```

**Очікуваний результат:** Статус 201, учасник доданий

#### Крок 6: Оновлення проєкту

```
PUT http://localhost:4002/api/projects/1
Content-Type: application/json

{
  "status": "in_progress",
  "priority": "critical"
}
```

**Очікуваний результат:** Статус 200, проєкт оновлено

#### Крок 7: Видалення учасника

```
DELETE http://localhost:4002/api/projects/1/members/2
```

**Очікуваний результат:** Статус 200, учасник видалений

#### Крок 8: Видалення проєкту

```
DELETE http://localhost:4002/api/projects/1
```

**Очікуваний результат:** Статус 200, проєкт видалений

#### Крок 9: Перевірка видалення

```
GET http://localhost:4002/api/projects/1
```

**Очікуваний результат:** Статус 404, проєкт не знайдено

### Результати тестування

Всі тести пройшли успішно:

| Тест | Метод | Endpoint | Статус | Результат |
|------|-------|----------|--------|-----------|
| Health Check | GET | /health | 200 | ✓ Пройдено |
| Get All Projects | GET | /api/projects | 200 | ✓ Пройдено |
| Get Project by ID | GET | /api/projects/:id | 200 | ✓ Пройдено |
| Create Project | POST | /api/projects | 201 | ✓ Пройдено |
| Update Project | PUT | /api/projects/:id | 200 | ✓ Пройдено |
| Delete Project | DELETE | /api/projects/:id | 200 | ✓ Пройдено |
| Add Member | POST | /api/projects/:id/members | 201 | ✓ Пройдено |
| Remove Member | DELETE | /api/projects/:id/members/:user_id | 200 | ✓ Пройдено |

---

## Висновки

В результаті виконання лабораторної роботи №5 було успішно розроблено прототип мікросервісу **Projects Service** для системи управління проєктами TaskFlow.

### Досягнуті результати:

1. **Реалізовано повний REST API** з 8 endpoint'ами для CRUD операцій над проєктами та управління учасниками

2. **Створено схему бази даних PostgreSQL** з двома таблицями (projects та project_members), встановлено зв'язки та індекси для оптимізації запитів

3. **Розроблено модульну архітектуру** з чітким розділенням відповідальності:
   - Конфігурація БД
   - Моделі даних
   - Контролери бізнес-логіки
   - Маршрути API
   - Middleware для обробки помилок

4. **Реалізовано контейнеризацію** з використанням Docker multi-stage build для оптимізації розміру образу та підвищення безпеки

5. **Налаштовано Docker Compose** для оркестрації мікросервісу та бази даних з health checks та автоматичним перезапуском

6. **Створено Postman колекцію** для тестування всіх endpoint'ів API

7. **Задокументовано API** з детальним описом запитів, відповідей та форматів даних

### Технічні особливості реалізації:

- Використано TypeScript для типобезпеки
- Застосовано пул з'єднань для ефективної роботи з БД
- Реалізовано динамічні SQL запити з параметризацією
- Додано валідацію вхідних даних
- Створено стандартизовані формати відповідей
- Застосовано каскадне видалення для підтримки цілісності даних

### Практична цінність:

Розроблений прототип демонструє базові принципи побудови мікросервісів:
- Незалежність та автономність сервісу
- Чітко визначений API контракт
- Ізоляція даних (власна база даних)
- Можливість незалежного розгортання
- Контейнеризація для портативності

Цей прототип може бути використаний як основа для реалізації повноцінного мікросервісу з додаванням:
- Аутентифікації та авторизації (JWT)
- Взаємодії з іншими мікросервісами через RabbitMQ
- Логування та моніторингу
- Кешування Redis
- CI/CD pipeline

### Отримані навички:

- Проєктування REST API
- Робота з PostgreSQL та pg драйвером
- Розробка на Node.js + TypeScript + Express
- Контейнеризація з Docker
- Оркестрація з Docker Compose
- Тестування API з Postman
- Документування технічних рішень

Лабораторна робота виконана повністю, всі поставлені завдання реалізовані та протестовані.

---

**Дата виконання:** 18 грудня 2025 року
