# Відповіді на питання до іспиту з дисципліни "Архітектура розподілених програмних систем"

## Алгоритми та структури даних

**1. Проблема вибору структури даних**
*Питання:* Опишіть, як вибір між масивом, зв'язаним списком та хеш-таблицею впливає на загальну продуктивність (часова та просторова складність) інформаційної системи. Наведіть конкретний приклад, де використання хеш-таблиці є критично важливим для швидкодії.

*Відповідь:*
Вибір структури даних визначає ефективність основних операцій: доступу, пошуку, вставки та видалення.
*   **Масив:** Забезпечує доступ до елементів за індексом за O(1), але вставка/видалення (не в кінець) вимагає зсуву елементів, що займає O(n). Ефективний для статичних даних або коли важливий швидкий доступ за індексом.
*   **Зв'язаний список:** Дозволяє швидку вставку/видалення за O(1) (якщо є посилання на вузол), але доступ до елемента вимагає перебору за O(n). Використовується, коли кількість елементів невідома заздалегідь і часті операції вставки/видалення.
*   **Хеш-таблиця:** Забезпечує пошук, вставку та видалення в середньому за O(1). Однак, у найгіршому випадку (багато колізій) складність може зрости до O(n). Вимагає більше пам'яті для зберігання хешів та посилань.

*Приклад:* Система аутентифікації користувачів, де потрібно миттєво перевірити наявність активної сесії за її ID (токеном). Використання хеш-таблиці дозволяє знаходити сесію за O(1), тоді як пошук у списку зайняв би O(n), що при мільйонах користувачів призвело б до неприпустимих затримок.

**2. Аналіз складності**
*Питання:* Поясніть поняття часової складності алгоритмів (O-нотація) та її значення для архітектора ІС. Порівняйте алгоритм із O(n) та алгоритм із O(log n) у контексті обробки великих обсягів даних.

*Відповідь:*
Часова складність (Big O) описує, як зростає час виконання алгоритму зі збільшенням вхідних даних (n). Для архітектора це інструмент прогнозування масштабованості системи.
*   **O(n) (лінійна):** Час виконання зростає прямо пропорційно кількості даних.
*   **O(log n) (логарифмічна):** Час зростає дуже повільно. Наприклад, подвоєння даних додає лише одну операцію.

*Порівняння:* При обробці 1 мільярда записів алгоритм O(n) виконає 1 мільярд операцій, а O(log n) (наприклад, бінарний пошук) — лише близько 30. Для великих даних O(log n) є критично ефективнішим.

**3. Порівняння структур для пріоритету**
*Питання:* Порівняйте використання бінарної купи (Binary Heap) та відсортованого зв'язаного списку для реалізації Черги з пріоритетом у системі. Яка структура даних є кращою з точки зору часової складності операцій вставки та вилучення елемента з найвищим пріоритетом, і чому?

*Відповідь:*
*   **Відсортований зв'язаний список:**
    *   Вилучення max/min: O(1) (беремо перший/останній елемент).
    *   Вставка: O(n) (потрібно знайти місце для вставки, щоб зберегти сортування).
*   **Бінарна купа (Binary Heap):**
    *   Вилучення max/min: O(log n) (потрібно відновити властивості купи).
    *   Вставка: O(log n).

*Висновок:* Бінарна купа є кращою для черги з пріоритетом, оскільки вона гарантує логарифмічну складність для обох операцій. У списку вставка за O(n) стане вузьким місцем при великій кількості елементів.

**4. Алгоритми, розрахунок ресурсів**
*Питання:* Поясніть, як архітектор ІС використовує аналіз часової складності (наприклад, O(n) або O(n^2)) для прогнозування потреби системи в ресурсах (CPU, пам'ять) при зростанні обсягу даних. Наведіть приклад, де неефективний алгоритм стає причиною архітектурного 'вузького місця'.

*Відповідь:*
Знаючи O-нотацію, архітектор може оцінити, як зміниться навантаження на CPU при зростанні аудиторії. Якщо алгоритм O(n^2), то збільшення даних у 10 разів збільшить навантаження у 100 разів. Це дозволяє планувати потужності серверів (Capacity Planning).

*Приклад:* Вкладені цикли при обробці списку замовлень (порівняння кожного з кожним для пошуку дублікатів) дають O(n^2). При 100 замовленнях це 10,000 операцій (швидко), але при 100,000 замовленнях — 10 мільярдів операцій, що "покладе" CPU і зупинить систему.

**5. Хеш-таблиці та колізії**
*Питання:* Поясніть, що таке хеш-колізії та коефіцієнт заповнення (load factor) у хеш-таблицях. Які архітектурні методи використовуються для вирішення колізій (наприклад, метод ланцюжків чи відкрита адресація) і як вони впливають на теоретичну продуктивність пошуку O(1)?

*Відповідь:*
*   **Колізія:** Ситуація, коли хеш-функція повертає однаковий індекс для різних ключів.
*   **Load Factor:** Відношення кількості елементів до розміру таблиці. Високий load factor збільшує ймовірність колізій.
*   **Методи вирішення:**
    *   *Ланцюжки (Chaining):* У кожній комірці зберігається список елементів. При колізії елемент додається в список. Пошук стає O(1) + довжина списку.
    *   *Відкрита адресація (Open Addressing):* Шукається наступна вільна комірка.
*   **Вплив:** Колізії погіршують продуктивність з O(1) до O(n) у найгіршому випадку. Для підтримки O(1) потрібно тримати load factor низьким (ресайзинг таблиці).

## Кешування

**6. Рівні та стратегії кешування**
*Питання:* Опишіть архітектурну модель багаторівневого кешування в розподіленій системі (наприклад, кеш браузера, CDN/зворотне проксі, кеш додатку, кеш БД). Які переваги та недоліки має кожен рівень?

*Відповідь:*
1.  **Кеш браузера:** Зберігає статику (CSS, JS, картинки) на клієнті. *Перевага:* миттєве завантаження, 0 трафіку. *Недолік:* важко інвалідувати (оновити) примусово.
2.  **CDN / Reverse Proxy (Nginx, Cloudflare):** Кешує контент на межі мережі (ближче до користувача). *Перевага:* знімає навантаження з бекенду, прискорює доставку по світу. *Недолік:* затримка оновлення контенту.
3.  **Кеш додатку (Redis, Memcached):** Зберігає результати важких обчислень або запитів. *Перевага:* швидкий доступ до даних, розвантаження БД. *Недолік:* ризик розсинхронізації з БД, складність підтримки.
4.  **Кеш БД:** Вбудовані буфери бази даних. *Перевага:* прозоро для розробника. *Недолік:* обмежений ресурсами сервера БД.

**7. Вибір політики витіснення**
*Питання:* Порівняйте та протиставте політики витіснення кешу LRU (Least Recently Used) та LFU (Least Frequently Used). В яких сценаріях (типовий робочий набір даних) краще використовувати кожну з них?

*Відповідь:*
*   **LRU (Найменш нещодавно використаний):** Видаляє елементи, до яких найдовше не зверталися.
    *   *Сценарій:* Соціальні мережі (стрічка новин), де актуальні останні дані. Якщо користувач подивився пост, ймовірно, він ще деякий час буде актуальним, а старі пости ні.
*   **LFU (Найменш часто використаний):** Видаляє елементи з найменшою частотою звернень.
    *   *Сценарій:* Словники, довідники, статичні дані, де є "популярні" записи, які завжди мають бути в кеші, незалежно від того, коли до них зверталися востаннє.

**8. Проблема узгодженості кешу**
*Питання:* Поясніть проблему когерентності (узгодженості) кешу в розподілених системах. Опишіть два основні підходи до її вирішення (наприклад, Cache-Aside з TTL, Write-Through або Invalidation Strategy).

*Відповідь:*
Проблема полягає в тому, що дані в кеші можуть застаріти порівняно з даними в основній базі даних (stale data).
*   **Cache-Aside з TTL (Time To Live):** Додаток читає з кешу; якщо немає — читає з БД і кладе в кеш. Дані "протухають" автоматично через час TTL. *Плюс:* простота. *Мінус:* можлива неузгодженість протягом часу TTL.
*   **Write-Through (Наскрізний запис):** Додаток пише дані в кеш, а кеш синхронно пише в БД. *Плюс:* дані завжди актуальні. *Мінус:* повільніший запис (потрібно писати в два місця).
*   **Invalidation (Інвалідація):** При зміні даних у БД, відповідний запис у кеші примусово видаляється.

**9. Безпека та кешування**
*Питання:* Які ризики безпеки пов'язані з кешуванням даних (наприклад, кешування конфіденційних даних, атаки на кеш (Cache Poisoning) або неправильне очищення)? Які архітектурні механізми (наприклад, ізоляція, контроль доступу, TTL для чутливих даних) слід застосовувати для захисту кешованої інформації?

*Відповідь:*
*   **Ризики:**
    *   Витік персональних даних (PII), якщо вони кешуються на CDN або в спільних кешах.
    *   Cache Poisoning: зловмисник підміняє відповідь у кеші, і всі користувачі отримують шкідливий контент.
*   **Захист:**
    *   Не кешувати чутливі дані на публічних CDN (header `Cache-Control: private`).
    *   Шифрування даних у кеші.
    *   Короткий TTL для важливих даних.
    *   Ізоляція кешів (Redis з паролем/ACL, VPC).

## Контейнеризація та оркестрування

**10. Контейнеризація vs. Віртуалізація**
*Питання:* Проаналізуйте ключові архітектурні відмінності між контейнеризацією (наприклад, Docker) та повною віртуалізацією (наприклад, VM). Чому контейнеризація стала домінуючим підходом для розгортання мікросервісів?

*Відповідь:*
*   **VM (Віртуальні машини):** Емулюють повне апаратне забезпечення і запускають повноцінну гостьову ОС. Важкі, довго запускаються, займають багато ресурсів.
*   **Контейнери (Docker):** Використовують ядро хостової ОС, ізолюючи лише процеси та файлову систему. Легкі (МБ, а не ГБ), запускаються за секунди.
*   **Чому домінують:** Ідеальні для мікросервісів, бо дозволяють запустити сотні ізольованих сервісів на одному сервері з мінімальними накладними витратами (overhead) і гарантують "працює скрізь однаково".

**11. Роль Kubernetes**
*Питання:* Опишіть основні функції та архітектурні компоненти Kubernetes (Master/Control Plane, Node, Pod, Service, Deployment). Як Kubernetes забезпечує самовідновлення та автоматичне масштабування додатків?

*Відповідь:*
*   **Компоненти:**
    *   *Control Plane:* Керує кластером (API Server, Scheduler, etcd).
    *   *Node:* Робоча машина, де запускаються контейнери.
    *   *Pod:* Мінімальна одиниця розгортання (один або кілька контейнерів).
    *   *Service:* Мережева абстракція для доступу до групи Pod-ів.
    *   *Deployment:* Описує бажаний стан (версію, к-сть реплік).
*   **Самовідновлення:** Якщо Pod падає, Controller Manager помічає невідповідність бажаному стану і запускає новий Pod.
*   **Масштабування:** Horizontal Pod Autoscaler (HPA) автоматично додає Pod-и при зростанні навантаження (CPU/RAM).

**12. CI/CD з контейнерами**
*Питання:* Поясніть, як контейнеризація інтегрується в сучасний конвеєр CI/CD і як це впливає на швидкість та надійність розгортання ІС.

*Відповідь:*
Контейнер стає єдиним артефактом, який проходить через усі етапи (Build -> Test -> Staging -> Prod).
*   **CI:** Код комітиться, збирається Docker-образ, проганяються тести всередині контейнера.
*   **CD:** Цей же образ (immutable artifact) розгортається на продакшн.
*   **Вплив:** Усуває проблему "працює на моїй машині". Гарантує, що тестується саме те, що буде працювати в проді. Прискорює розгортання та відкат (rollback).

**13. Стійкість даних**
*Питання:* Яким чином вирішується проблема збереження стійких даних (persistent storage) у контейнеризованих середовищах, які за своєю природою є тимчасовими? Опишіть концепцію Volumes (томи) у Docker/Kubernetes.

*Відповідь:*
Контейнери ефемерні (дані зникають при перезапуску). Для збереження даних використовуються **Volumes**.
*   **Docker Volume:** Директорія на хостовій машині, яка монтується в контейнер. Дані живуть незалежно від життєвого циклу контейнера.
*   **K8s Persistent Volume (PV) / Claim (PVC):** Абстракція над фізичним сховищем (хмарний диск, NFS). Под запитує сховище через PVC, і K8s монтує відповідний диск. Це дозволяє базі даних зберігати стан навіть при переміщенні Pod-а на іншу ноду.

**14. Контейнери, безпека**
*Питання:* Опишіть ключові проблеми безпеки в середовищах контейнеризації та оркестрування. Які архітектурні практики та інструменти слід використовувати для їх мінімізації?

*Відповідь:*
*   **Проблеми:** Вразливості в образах, запуск від root, спільне ядро (вихід з контейнера може скомпрометувати хост), відкриті порти.
*   **Практики:**
    *   Сканування образів на вразливості (Trivy, Clair).
    *   Використання мінімальних образів (Distroless, Alpine).
    *   Запуск контейнерів не від root (User namespaces).
    *   Network Policies в K8s для обмеження трафіку між сервісами.
    *   RBAC для обмеження доступу до API кластера.

## Бази даних

**15. ACID та CAP**
*Питання:* Поясніть принципи ACID (для реляційних БД) та теорему CAP (для розподілених систем). Чому розподілені NoSQL системи часто жертвують 'C' (Consistency) на користь 'A' (Availability) та 'P' (Partition Tolerance)?

*Відповідь:*
*   **ACID:** Atomicity, Consistency, Isolation, Durability. Гарантує надійність транзакцій у монолітних БД.
*   **CAP:** У розподіленій системі можна одночасно забезпечити лише два з трьох: Consistency (узгодженість), Availability (доступність), Partition Tolerance (стійкість до розділення мережі).
*   **Чому жертвують C:** У розподілених системах P є обов'язковим (мережа ненадійна). Вибір стоїть між A і C. Для високонавантажених систем (Amazon, Facebook) простій неприпустимий (потрібна A), тому вони обирають модель Eventual Consistency (узгодженість у кінцевому рахунку), жертвують миттєвою строгістю даних заради того, щоб система завжди відповідала.

**16. Порівняння SQL та NoSQL**
*Питання:* Порівняйте реляційні (SQL) та нереляційні (NoSQL) бази даних за критеріями схеми даних, масштабованості та моделі транзакцій. В яких архітектурних сценаріях доцільно використовувати документо-орієнтовані NoSQL БД?

*Відповідь:*
*   **SQL:** Жорстка схема (таблиці), вертикальне масштабування (потужніший сервер), суворі ACID транзакції.
*   **NoSQL:** Гнучка схема (JSON, ключ-значення), легке горизонтальне масштабування (шардінг), часто BASE транзакції (м'якші).
*   **Документо-орієнтовані (MongoDB):** Доцільні для CMS, каталогів товарів, профілів користувачів, де структура даних часто змінюється, дані ієрархічні, і не потрібні складні JOIN-запити.

**17. Схеми БД**
*Питання:* Опишіть різницю між концептуальною, логічною та фізичною схемами БД. Яку роль відіграє кожна схема в процесі проєктування ІС, і які абстракції вона надає?

*Відповідь:*
1.  **Концептуальна:** Високорівневий опис сутностей і зв'язків (ER-діаграма) без прив'язки до технологій. Зрозуміла бізнесу.
2.  **Логічна:** Деталізація атрибутів, типів даних, ключів (PK, FK), нормалізація. Вже схожа на таблиці, але ще без специфіки конкретної СУБД.
3.  **Фізична:** SQL-скрипти (DDL), індекси, партиціонування, налаштування зберігання для конкретної СУБД (PostgreSQL, Oracle).

**18. Масштабування БД**
*Питання:* Поясніть архітектурні стратегії горизонтального (sharding) та вертикального масштабування реляційних БД. Які проблеми виникають при шардуванні і як їх можна мінімізувати?

*Відповідь:*
*   **Вертикальне:** Додати RAM/CPU на сервер. Просто, але є фізична межа і дорого.
*   **Горизонтальне (Sharding):** Розподіл даних по кількох серверах за певним ключем (наприклад, user_id).
*   **Проблеми шардування:** Складність JOIN-запитів між шардами (cross-shard joins), складність транзакцій, нерівномірний розподіл даних.
*   **Мінімізація:** Вибирати ключ шардування так, щоб пов'язані дані лежали на одному шарді; денормалізація даних; використання спеціальних middleware (Vitess).

**19. Бази даних, індексація**
*Питання:* Детально поясніть принцип роботи індексації в реляційних СУБД (наприклад, B-tree індекс). Обговоріть компроміс між швидкістю читання (SELECT) та швидкістю запису/оновлення (INSERT/UPDATE) при використанні індексів.

*Відповідь:*
*   **B-tree:** Збалансоване дерево пошуку. Дозволяє знаходити дані за O(log n) замість повного сканування таблиці O(n).
*   **Компроміс:** Індекси значно прискорюють читання (`SELECT`). Але при кожному `INSERT`, `UPDATE` або `DELETE` база даних мусить оновлювати не тільки саму таблицю, а й усі побудовані індекси (перебудовувати дерево). Тому велика кількість індексів сповільнює запис.

## Хмарні провайдери

**20. Модель спільної відповідальності**
*Питання:* Поясніть концепцію Моделі спільної відповідальності у хмарних обчисленнях. Наведіть приклади для IaaS та PaaS.

*Відповідь:*
Провайдер і клієнт ділять відповідальність за безпеку.
*   **IaaS (EC2):** Провайдер відповідає за "залізо", мережу, фізичну безпеку дата-центру. Клієнт — за ОС, патчі, фаєрвол, додатки, дані.
*   **PaaS (RDS, App Engine):** Провайдер бере на себе ОС, рантайм, патчі бази даних. Клієнт відповідає лише за код додатку та свої дані.

**21. Vendor Lock-in**
*Питання:* Що таке Vendor Lock-in та стратегії його уникнення?

*Відповідь:*
Залежність від унікальних сервісів провайдера, що ускладнює переїзд до іншого.
*   **Уникнення:**
    *   Використання контейнерів (Docker/K8s) — стандартна упаковка.
    *   Infrastructure as Code (Terraform) — універсальний опис інфраструктури.
    *   Використання відкритих стандартів (SQL, S3-compatible storage) замість пропрієтарних API (DynamoDB, Firestore).

**22. Serverless (FaaS)**
*Питання:* Що таке архітектура Serverless (FaaS)? Переваги та виклики.

*Відповідь:*
Виконання коду (функцій) без управління серверами.
*   **Переваги:** Оплата тільки за час виконання (мілісекунди), автоматичне нескінченне масштабування, відсутність адміністрування.
*   **Виклики:** "Холодний старт" (затримка при першому запуску), обмеження часу виконання, складність відлагодження, сильний Vendor Lock-in.

**23. Хмара, еластичність та відмовостійкість**
*Питання:* Поясніть різницю між еластичністю та відмовостійкістю. Як хмарні сервіси їх забезпечують?

*Відповідь:*
*   **Еластичність (Elasticity):** Здатність автоматично збільшувати/зменшувати ресурси відповідно до навантаження (Auto Scaling). Економить гроші.
*   **Відмовостійкість (Fault Tolerance):** Здатність продовжувати роботу при виході з ладу компонентів. Забезпечується надмірністю (реплікація VM у різних зонах доступності).

## Архітектура розподілених систем. REST та gRPC

**24. Принципи REST**
*Питання:* Опишіть принципи REST (Statelessness, Uniform Interface). Як вони сприяють масштабованості?

*Відповідь:*
*   **Statelessness:** Сервер не зберігає стан клієнта між запитами. Кожен запит містить всю необхідну інформацію. Це дозволяє легко масштабувати сервери (будь-який сервер може обробити будь-який запит).
*   **Uniform Interface:** Єдиний спосіб взаємодії (GET, POST, URI), що спрощує інтеграцію та розробку клієнтів.

**25. Відмінності REST vs. gRPC**
*Питання:* Порівняльний аналіз REST та gRPC.

*Відповідь:*
*   **REST:** Текстовий (JSON), HTTP/1.1, читабельний для людини, широкий інструментарій. Повільніший (парсинг тексту, розмір пакетів).
*   **gRPC:** Бінарний (Protobuf), HTTP/2, строго типізований, генерація коду клієнта/сервера. Значно швидший і компактніший. Ідеальний для внутрішньої комунікації мікросервісів.

**26. Idempotency та HTTP-методи**
*Питання:* Поясніть концепцію ідемпотентності. Які методи є ідемпотентними?

*Відповідь:*
Ідемпотентність — властивість операції давати той самий результат при багаторазовому виконанні.
*   **Ідемпотентні:** `GET` (читання), `PUT` (повне оновлення), `DELETE` (видалення). Якщо повторити запит — стан системи не зміниться (або буде таким самим, як після першого разу).
*   **Не ідемпотентні:** `POST` (створення). Повтор запиту створить дублікат ресурсу.
*   *Значення:* Дозволяє безпечно повторювати запити при збоях мережі (retry policy).

**27. Синхронна та Асинхронна комунікація**
*Питання:* Порівняйте синхронні та асинхронні підходи. Коли необхідна асинхронність?

*Відповідь:*
*   **Синхронна (REST):** Клієнт чекає відповіді. Проста, але блокує клієнта і створює сильну зв'язність.
*   **Асинхронна (RabbitMQ):** Клієнт відправляє повідомлення і не чекає.
*   *Необхідність:* Для довгих операцій (генерація звіту), для згладжування пікових навантажень (черга замовлень), для відв'язування сервісів.

**28. Маршалінг та Protobuf**
*Питання:* Роль маршалінгу в gRPC та переваги Protobuf.

*Відповідь:*
Маршалінг — перетворення об'єкта в пам'яті у формат для передачі.
*   **Protobuf:** Використовує бінарний формат і схему (.proto). Це дозволяє стискати дані набагато краще за JSON і уникати повільного парсингу тексту. Забезпечує крос-мовну сумісність через генерацію коду.

## SOA та Мікросервісна архітектура

**29. SOA vs. Мікросервіси**
*Питання:* Еволюція від Моноліту до SOA та Мікросервісів. Роль ESB.

*Відповідь:*
*   **SOA:** Сервіси великі, інтегруються через розумну шину **ESB** (Enterprise Service Bus), яка містить бізнес-логіку маршрутизації та трансформації.
*   **Мікросервіси:** Сервіси малі, "розумні endpoints, дурні труби". ESB замінюється на легкі брокери повідомлень або API Gateway без складної логіки. Мікросервіси більш незалежні у розгортанні.

**30. Проблеми розподілених транзакцій**
*Питання:* Проблеми розподілених транзакцій та шаблон Saga.

*Відповідь:*
У мікросервісах неможливо використати класичні ACID транзакції (Two-Phase Commit повільний і блокуючий).
*   **Saga:** Послідовність локальних транзакцій у кожному сервісі. Якщо одна ланка ламається, запускаються компенсаційні транзакції (відкат змін) у зворотньому порядку. Забезпечує узгодженість у кінцевому рахунку.

**31. API Gateway**
*Питання:* Роль та функції API Gateway.

*Відповідь:*
Єдина точка входу для клієнтів.
*   **Функції:**
    1.  Аутентифікація та авторизація.
    2.  Rate Limiting (обмеження запитів).
    3.  Агрегація відповідей від кількох сервісів.
    4.  Трансформація протоколів (HTTP -> gRPC).
    5.  Кешування.

**32. Залежності та комунікація в мікросервісах**
*Питання:* Проблема сильної зв'язаності (tight coupling) та її вирішення через DDD і асинхронність.

*Відповідь:*
Сильна зв'язність (прямі HTTP виклики) призводить до того, що падіння одного сервісу кладе інші.
*   **DDD:** Допомагає правильно визначити Bounded Contexts (межі сервісів), щоб мінімізувати необхідність спілкування між ними.
*   **Асинхронність:** Використання подій (Domain Events). Сервіс А публікує подію "Замовлення створено", Сервіс Б реагує. Вони не знають один про одного.

**33. Шаблон Circuit Breaker**
*Питання:* Опишіть шаблон Circuit Breaker. Яку проблему каскадних збоїв він вирішує?

*Відповідь:*
Запобігає спробам викликати сервіс, який, ймовірно, мертвий, щоб не витрачати ресурси і дати йому час відновитися.
*   **Стани:**
    1.  *Closed:* Запити проходять (все ок).
    2.  *Open:* Запити блокуються миттєво (помилка), якщо кількість помилок перевищила поріг.
    3.  *Half-Open:* Пробний пропуск одного запиту. Якщо успішний — перехід у Closed, якщо ні — назад в Open.

## Діаграми

**34. UML, діаграми взаємодії**
*Питання:* Призначення діаграми Послідовності (Sequence Diagram) UML.

*Відповідь:*
Показує взаємодію об'єктів (або сервісів) у часі.
*   **Елементи:** Актори, лінії життя (Lifelines), повідомлення (синхронні/асинхронні), блоки активації.
*   **Використання:** Архітектор використовує її для деталізації сценаріїв (Use Cases), щоб показати точний порядок викликів між мікросервісами, API та базами даних, що дозволяє виявити логічні помилки ще до написання коду.
