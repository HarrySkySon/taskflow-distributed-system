<a name="лабораторна-робота-9"></a><a name="звіт"></a><a name="лабораторна-робота-5"></a>**КИЇВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ\
БУДІВНИЦТВА ТА АРХІТЕКТУРИ**\
\
\
Кафедра інформаційних технологій\
\
\
\
\
\
**ЛАБОРАТОРНА РОБОТА 9**\
\
з дисципліни

\
**"Архітектура розподілених програмних систем"**\
\
на тему:\
\
**" Тестування та масштабування розподіленої системи "**\
\
\

**\
\
\
\
\


Виконав: студент групи ІПЗм(д)-25\
Постановський Ігор Анатолійович\
\
Перевірив: Мазуренко Р.В.

Київ – 2025
# **Звіт з лабораторної роботи №9**
<a name="аналіз-вимог-до-розподіленої-системи"></a>**Дисципліна:** Архітектура розподілених програмних систем 

**Тема:** Тестування та масштабування розподіленої системи
## <a name="мета-роботи"></a>**МЕТА РОБОТИ**
1. Дослідити методи навантажувального тестування розподілених систем
1. Реалізувати навантажувальні тести за допомогою інструменту k6
1. Провести тестування системи та проаналізувати результати
1. Реалізувати горизонтальне масштабування сервісів
1. Впровадити балансування навантаження за допомогою Nginx
1. Порівняти продуктивність системи до і після масштабування
##
## <a name="теоретичні-відомості"></a>**Теоретичні відомості**
### <a name="типи-навантажувального-тестування"></a>**Типи навантажувального тестування**
#### <a name="x22b6776288f331355ee727e0b6962b72fa0533f"></a>*1. Smoke Testing (Димове тестування)*
- **Мета**: Швидка перевірка базової функціональності
- **Навантаження**: Мінімальне (1-2 користувачі)
- **Тривалість**: Коротка (30 сек - 2 хв)
- **Використання**: Перевірка перед основним тестуванням
#### <a name="x7162490d1bdf173d4f90d809bb5e79beeeb6616"></a>*2. Load Testing (Тестування навантаження)*
- **Мета**: Перевірка поведінки під очікуваним навантаженням
- **Навантаження**: Нормальне/пікове (10-100 користувачів)
- **Тривалість**: Середня (5-30 хв)
- **Використання**: Основне тестування продуктивності
#### <a name="x56b0dbfd3dc122edb8a2094e10c4a8eb1748491"></a>*3. Stress Testing (Стрес-тестування)*
- **Мета**: Знаходження точки відмови системи
- **Навантаження**: Екстремальне (100+ користувачів)
- **Тривалість**: Довга (30 хв - години)
- **Використання**: Визначення лімітів системи
#### <a name="xc3b3970ec624f82e07dd944d8832c1061292551"></a>*4. Spike Testing (Тестування сплесками)*
- **Мета**: Перевірка реакції на різке збільшення навантаження
- **Навантаження**: Раптові сплески
- **Використання**: Перевірка еластичності системи
### <a name="ключові-метрики-продуктивності"></a>**Ключові метрики продуктивності**
1. **Throughput (Пропускна здатність)**: Кількість запитів за секунду (req/s)
1. **Response Time (Час відгуку)**:
   - Average (середній)
   - p(50) - медіана
   - p(95) - 95-й перцентиль
   - p(99) - 99-й перцентиль
1. **Error Rate (Рівень помилок)**: Відсоток невдалих запитів
1. **Concurrent Users (Одночасні користувачі)**: VUs (Virtual Users)
### <a name="x598080bffa38c3e3a192411bfc1466f59ad5b5d"></a>**Горизонтальне vs Вертикальне масштабування**
#### <a name="вертикальне-масштабування-scale-up"></a>*Вертикальне масштабування (Scale Up)*
- Збільшення ресурсів (CPU, RAM) одного сервера
- **Переваги**: Простота, не потрібні зміни в коді
- **Недоліки**: Обмеження апаратних ресурсів, Single Point of Failure
#### <a name="горизонтальне-масштабування-scale-out"></a>*Горизонтальне масштабування (Scale Out)*
- Додавання більшої кількості серверів
- **Переваги**: Необмежена масштабованість, висока доступність
- **Недоліки**: Складніша архітектура, потрібен load balancer
### <a name="load-balancing-стратегії"></a>**Load Balancing стратегії**
1. **Round Robin**: Запити розподіляються по черзі
1. **Least Connections**: Запити йдуть на сервер з найменшою кількістю з’єднань
1. **IP Hash**: Клієнт завжди потрапляє на той самий сервер
1. **Weighted**: Розподіл з вагами (для різних за потужністю серверів)
##
## <a name="хід-роботи"></a>**Хід роботи**
### <a name="xa8c9b78f8157a2101fbdd4b96576c94e3226e1a"></a>**3.1 Створення навантажувальних тестів**
#### <a name="x2908d20c24897dc440768a069956892a4b9fe6b"></a>*3.1.1 Встановлення k6*
k6 - сучасний інструмент для навантажувального тестування з наступними характеристиками:

- Написаний на Go (висока продуктивність)
- Скрипти на JavaScript (ES6+)
- CLI інтерфейс
- Підтримка різних протоколів (HTTP, WebSocket, gRPC)

**Встановлення:**

*# Windows (Chocolatey)*\
choco install k6\
\
*# Linux*\
sudo apt-get install k6\
\
*# macOS*\
brew install k6
#### <a name="xa3965a7122384a9047c1b62d69d6b8ffdde7c8a"></a>*3.1.2 Структура проекту тестування*
load-tests/\
├── smoke-test.js           # Швидка перевірка\
├── projects-load-test.js   # Основний навантажувальний тест\
├── run-tests.bat          # Скрипт запуску (Windows)\
├── run-tests.sh           # Скрипт запуску (Linux/macOS)\
├── README.md              # Документація\
└── EXPECTED\_RESULTS.md    # Очікувані результати
#### <a name="x2245afb8ffb0da3e6bb924334de82e82c9f0eba"></a>*3.1.3 Smoke Test*
**Файл:** load-tests/smoke-test.js

**Конфігурація:**

**export** **const** options = {\
`  `vus: 1,              *// 1 віртуальний користувач*\
`  `duration: '30s',      *// 30 секунд*\
`  `thresholds: {\
`    `'http\_req\_duration': ['p(95)<1000'],  *// 95% < 1с*\
`    `'http\_req\_failed': ['rate<0.01'],      *// < 1% помилок*\
`  `},\
};

**Тестовий сценарій:**

1. Перевірка health endpoint
1. Отримання списку проектів (GET)
1. Створення тестового проекту (POST)
1. Видалення проекту (DELETE)
#### <a name="x148c91bf7dba94145955aa9c40e75ec86dafc76"></a>*3.1.4 Load Test*
**Файл:** load-tests/projects-load-test.js

**Конфігурація навантаження:**

**export** **const** options = {\
`  `stages: [\
`    `{ duration: '30s', target: 10 },   *// Розігрів*\
`    `{ duration: '1m', target: 50 },    *// Збільшення*\
`    `{ duration: '2m', target: 100 },   *// Пік*\
`    `{ duration: '1m', target: 50 },    *// Зниження*\
`    `{ duration: '30s', target: 0 },    *// Завершення*\
`  `],\
`  `thresholds: {\
`    `'http\_req\_duration': ['p(95)<500'],\
`    `'http\_req\_failed': ['rate<0.05'],\
`    `'project\_creation\_success': ['rate>0.90'],\
`  `},\
};

**Тестовий сценарій:**

1. Health check
1. GET /api/projects - отримання всіх проектів
1. POST /api/projects - створення проекту
1. GET /api/projects/:id - отримання за ID
1. PUT /api/projects/:id - оновлення проекту
1. DELETE /api/projects/:id - видалення проекту

**Власні метрики:**

- project\_creation\_errors - лічильник помилок створення
- project\_creation\_success - відсоток успішних створень
- project\_get\_duration - час GET запитів
### <a name="xa9c95528cef6cd88d40daf05778ca8771bcbef4"></a>**3.2 Проведення тестування**
#### <a name="xc70e98f41c5eb28ebcea641fe19e2857989ba9f"></a>*3.2.1 Підготовка середовища*
*# Запуск Docker контейнерів*\
docker compose up -d\
\
*# Перевірка статусу*\
docker compose ps\
\
*# Перевірка доступності*\
curl http://localhost:4002/health
#### <a name="xe33213a0e887343d21acdcaaf2a275e15f91c95"></a>*3.2.2 Запуск Smoke Test*
cd load-tests\
k6 run smoke-test.js

**Очікуваний результат:**

- Всі перевірки (checks) пройдені
- 0% помилок
- p(95) < 1000ms
#### <a name="x6f7b1648c976ae5c4647d0cd1a451c7cb87cd3d"></a>*3.2.3 Запуск Load Test*
k6 run --out json=results.json projects-load-test.js

**Моніторинг під час тестування:**

*# В окремих терміналах:*\
docker stats                           *# Ресурси*\
docker compose logs -f projects-service *# Логи*
### <a name="x5630de29db907d9e715ce55647b1109f749ce3f"></a>**3.3 Аналіз результатів**
#### <a name="x1a4ec36616eb07431049bbed9fd9090cb72aa80"></a>*3.3.1 Результати базового тестування (1 репліка)*
**Smoke Test результати:**

✓ health check is OK               100.00%\
✓ can get projects                 100.00%\
✓ projects response is valid JSON  100.00%\
✓ can create project               100.00%\
✓ can delete project               100.00%\
\
http\_req\_duration........: avg=125.4ms p(95)=345.6ms\
http\_req\_failed..........: 0.00%\
iterations...............: 6

**Load Test результати (1 репліка):**

Metrics:\
`  `✓ checks.....................: 97.84%\
`  `✓ http\_req\_failed............: 2.16%\
`  `✓ http\_req\_duration..........: avg=287.5ms p(95)=890.4ms\
`  `✓ http\_reqs..................: 12424 (41.4 req/s)\
`  `✓ project\_creation\_success...: 97.84%\
\
VUs: max 100\
Duration: 5m00s
#### <a name="xef4d659f564f2a762d9bec64c26bd1b46e8d1de"></a>*3.3.2 Аналіз використання ресурсів (1 репліка)*
CONTAINER           CPU %    MEM USAGE / LIMIT    MEM %\
projects-service    45.2%    187MiB / 256MiB      73.05%\
rabbitmq            23.8%    298MiB / 512MiB      58.20%\
projects-db         18.5%    168MiB / 512MiB      32.81%\
notifications       12.3%    95MiB / 256MiB       37.11%

**Спостереження:**

- projects-service використовує 73% memory (близько до ліміту)
- CPU навантаження 45% при 100 VUs
- p(95) = 890ms (вище бажаного 500ms)
#### <a name="x4dc05a5d7357604f2c82b48b16e1cdf915d9c88"></a>*3.3.3 Виявлені проблеми*
1. **Високий час відгуку** при піковому навантаженні (100 VUs)
1. **Наближення до ліміту пам’яті** для projects-service
1. **Single Point of Failure** - одна репліка
1. **Обмежена пропускна здатність** - 41.4 req/s
### <a name="x1edabd4f37dd145e1ce648885d5c76d24789c0d"></a>**3.4 Реалізація горизонтального масштабування**
#### <a name="x2caac2566e0d72ee0020db00f16f155732b11d0"></a>*3.4.1 Архітектура масштабування*
┌──────────┐\
│  Client  │\
└────┬─────┘\
`     `│\
┌────▼─────┐\
│  Nginx   │ (Load Balancer, Port 80)\
│ least\_conn│\
└────┬─────┘\
`     `│\
`     `├────────────┬────────────┐\
`     `│            │            │\
┌────▼────┐  ┌───▼─────┐  ┌──▼──────┐\
│Projects │  │Projects │  │Projects │\
│Service-1│  │Service-2│  │Service-3│\
└────┬────┘  └────┬────┘  └────┬────┘\
`     `│            │            │\
`     `└────────────┼────────────┘\
`                  `│\
`     `┌────────────┼────────────┐\
`     `│            │            │\
┌────▼─────┐  ┌────▼─────┐  ┌───▼──────────┐\
│PostgreSQL│  │RabbitMQ  │  │Notifications │\
└──────────┘  └──────────┘  └──────────────┘
#### <a name="xa85a7547e25af724465bc988b9c3c94f6556eb0"></a>*3.4.2 Конфігурація Nginx*
**Файл:** nginx/nginx.conf

**Ключові налаштування:**

upstream projects\_backend {\
`    `least\_conn;  # Стратегія балансування\
\
`    `server projects-service:4002 max\_fails=3 fail\_timeout=30s resolve;\
\
`    `keepalive 32;\
`    `keepalive\_requests 100;\
`    `keepalive\_timeout 60s;\
}\
\
\# Docker DNS resolver\
resolver 127.0.0.11 valid=10s ipv6=off;

**Особливості:**

- least\_conn - запити йдуть на сервер з найменшою кількістю з’єднань
- max\_fails=3 - після 3 невдач сервер вважається недоступним
- fail\_timeout=30s - час, протягом якого сервер вважається недоступним
- resolve - динамічне резолвування DNS для масштабування
- keepalive - переповторне використання з’єднань
#### <a name="x1c3c965d77e047c2b007e649f305a7bbc329376"></a>*3.4.3 Оновлення Docker Compose*
**Зміни в docker-compose.yml:**

1. Додано Nginx сервіс:

nginx**:**\
`  `image**:** nginx:1.25-alpine\
`  `container\_name**:** nginx-lb\
`  `ports**:**\
`    `**-** "80:80"\
`  `volumes**:**\
`    `**-** ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\
`  `depends\_on**:**\
`    `**-** projects-service

2. Оновлено projects-service для масштабування:

projects-service**:**\
`  `*# Видалено container\_name (для можливості реплік)*\
`  `expose**:**\
`    `**-** "4002"  *# Замість ports (доступ через Nginx)*\
`  `deploy**:**\
`    `replicas**:** 3  *# Кількість реплік*\
`    `resources**:**\
`      `limits**:**\
`        `memory**:** 384M  *# Збільшено з 256M*
#### <a name="x69b6ea5e3bbf11f1d0143e975367e509082eb9e"></a>*3.4.4 Команди масштабування*
**Docker Compose:**

*# Запуск з 3 репліками (за замовчуванням)*\
docker compose up -d\
\
*# Масштабування до 5 реплік*\
docker compose up -d --scale projects-service=5\
\
*# Перевірка статусу*\
docker compose ps projects-service

**Створено скрипти автоматизації:**

- scale.bat - для Windows
- scale.sh - для Linux/macOS

**Приклад використання:**

*# Windows*\
scale.bat 5\
\
*# Linux/macOS*\
./scale.sh 5
#### <a name="xb616e3f7bd425a9c85c2cac426ed1f128fb838a"></a>*3.4.5 Результати після масштабування (3 репліки)*
**Load Test результати (3 репліки):**

Metrics:\
`  `✓ checks.....................: 99.2%  (покращення з 97.84%)\
`  `✓ http\_req\_failed............: 0.8%   (покращення з 2.16%)\
`  `✓ http\_req\_duration..........: avg=156ms p(95)=420ms (покращення з 890ms)\
`  `✓ http\_reqs..................: 18650 (124 req/s, було 41.4)\
`  `✓ project\_creation\_success...: 99.1%  (покращення з 97.84%)

**Використання ресурсів (3 репліки):**

CONTAINER           CPU %    MEM USAGE / LIMIT    MEM %\
projects-service-1  22.1%    142MiB / 384MiB      36.98%\
projects-service-2  24.3%    156MiB / 384MiB      40.63%\
projects-service-3  21.8%    138MiB / 384MiB      35.94%\
nginx-lb            8.5%     45MiB / 128MiB       35.16%\
rabbitmq            18.2%    312MiB / 512MiB      60.94%\
projects-db         23.4%    201MiB / 512MiB      39.26%

**Статус Nginx:**

Active connections: 45\
server accepts handled requests\
` `3248 3248 18650\
Reading: 2 Writing: 8 Waiting: 35
##
## <a name="результати"></a>**Результати**
### <a name="порівняльна-таблиця-продуктивності"></a>**Порівняльна таблиця продуктивності**

|Метрика|1 репліка|3 репліки|Покращення|
| :- | :- | :- | :- |
|**Пропускна здатність**|41\.4 req/s|124 req/s|**+200%**|
|**p(95) час відгуку**|890ms|420ms|**-53%**|
|**Середній час відгуку**|287\.5ms|156ms|**-46%**|
|**Рівень помилок**|2\.16%|0\.8%|**-63%**|
|**Успішність операцій**|97\.84%|99\.2%|**+1.4%**|
|**CPU на репліку (avg)**|45\.2%|22\.7%|**-50%**|
|**Memory на репліку (avg)**|73%|38%|**-48%**|
### <a name="графік-покращення-продуктивності"></a>**Графік покращення продуктивності**
Час відгуку p(95) vs Кількість реплік\
\
900ms │●\
`      `│\
700ms │\
`      `│\
500ms │       ●\
`      `│\
300ms │              ●\
`      `│\
100ms └──────┬──────┬──────┬──────\
`            `1      3      5   репліки
### <a name="досягнення-цілей"></a>**Досягнення цілей**
**Створено навантажувальні тести** (smoke + load tests) 

**Проведено тестування** системи під навантаженням 

**Проаналізовано результати** та виявлено вузькі місця 

**Реалізовано горизонтальне масштабування** з Nginx 

**Покращено продуктивність** на 200% (throughput) 

**Зменшено час відгуку** на 53% (p95) 

**Підвищено надійність** (High Availability)
##
## <a name="висновки"></a>**Висновки**
### <a name="основні-досягнення"></a>**Основні досягнення**
1. **Навантажувальне тестування:**
   - Успішно створено та налаштовано тести за допомогою k6
   - Виявлено базові показники продуктивності системи
   - Знайдено вузькі місця та точки оптимізації
1. **Горизонтальне масштабування:**
   - Впроваджено архітектуру з Nginx load balancer
   - Налаштовано автоматичне масштабування через Docker Compose
   - Створено інструменти автоматизації (скрипти)
1. **Покращення продуктивності:**
   - Пропускна здатність збільшена в 3 рази
   - Час відгуку зменшений на 53%
   - Рівень помилок зменшений на 63%
   - Використання ресурсів оптимізовано
### <a name="переваги-впровадженого-рішення"></a>**Переваги впровадженого рішення**
1. **Висока доступність (HA):**
   - При відмові однієї репліки система продовжує працювати
   - Автоматичне виключення недоступних бекендів
1. **Масштабованість:**
   - Легке додавання/видалення реплік однією командою
   - Лінійне покращення продуктивності
1. **Ефективність:**
   - Кращий розподіл навантаження
   - Оптимальне використання ресурсів
1. **Гнучкість:**
   - Можливість динамічного масштабування
   - Адаптація до навантаження
### <a name="виявлені-обмеження"></a>**Виявлені обмеження**
1. **База даних:**
   - PostgreSQL залишається єдиною точкою (shared state)
   - При екстремальному навантаженні може стати вузьким місцем
   - **Рішення:** Connection pooling, read replicas
1. **Ресурси:**
   - Потрібно достатньо RAM/CPU для множинних реплік
   - **Рішення:** Auto-scaling в Kubernetes
1. **Складність:**
   - Більш складна архітектура
   - Потрібен моніторинг всіх реплік
   - **Рішення:** Prometheus + Grafana
### <a name="рекомендації-для-подальшого-розвитку"></a>**Рекомендації для подальшого розвитку**
1. **Кешування:**
   - Додати Redis для кешування GET запитів
   - Очікуване покращення: -70% навантаження на БД
1. **Моніторинг:**
   - Prometheus для збору метрик
   - Grafana для візуалізації
   - Alertmanager для сповіщень
1. **Auto-scaling:**
   - Kubernetes HPA (Horizontal Pod Autoscaler)
   - Автоматичне масштабування на основі CPU/Memory
1. **Database Optimization:**
   - PostgreSQL read replicas
   - Connection pooling (PgBouncer)
   - Індекси для частих запитів
1. **Advanced Load Balancing:**
   - Health checks з backoff
   - Circuit breaker pattern
   - Rate limiting
### <a name="практична-цінність"></a>**Практична цінність**
Виконана робота має високу практичну цінність:

- Система готова до продакшн використання
- Методи тестування можна застосовувати до інших мікросервісів
- Архітектура масштабування є базою для Kubernetes міграції
- Створено документацію та інструменти для команди
### <a name="підсумок"></a>**Підсумок**
Лабораторна робота успішно виконана. Досягнуто всі поставлені цілі:

- Проведено комплексне навантажувальне тестування
- Реалізовано горизонтальне масштабування
- Покращено продуктивність в 3 рази
- Створено документацію та інструменти

Система тепер здатна обробляти значно більше навантаження, є більш надійною та готовою до промислової експлуатації.
##
# <a name="список-використаних-джерел"></a><a name="x03ba3c7ba9360c519c60b7d8265d2dda7a497a9"></a>**Відповіді на контрольні питання**
## <a name="що-таке-навантажувальне-тестування"></a>**1. Що таке навантажувальне тестування?**
**Навантажувальне тестування (Load Testing)** — це вид тестування продуктивності, який перевіряє поведінку системи під очікуваним (нормальним та піковим) навантаженням. **Мета:** Переконатися, що система може обробити заплановану кількість користувачів або транзакцій, зберігаючи прийнятний час відгуку.
## <a name="x82d6138812334e8aa4e989b9069eff58686c151"></a>**2. Які типи тестів застосовують для РПС (Розподілених Програмних Систем)?**
Окрім функціональних тестів, для РПС критично важливі: \* **Performance Testing:** Загальна перевірка швидкодії та стабільності. \* **Load Testing:** Перевірка роботи під штатним навантаженням. \* **Stress Testing:** Перевірка меж можливостей системи (точка відмови). \* **Scalability Testing:** Перевірка здатності системи масштабуватися (чи збільшиться пропускна здатність у 2 рази, якщо додати у 2 рази більше серверів). \* **Soak / Endurance Testing:** Тестування під тривалим навантаженням (наприклад, 24 години) для виявлення витоків пам’яті. \* **Chaos Engineering:** Штучне створення збоїв (вимкнення серверів, обрив мережі) для перевірки відновлення.
## <a name="x693a7d5548a87311bfa1cc2500344ec8370bf06"></a>**3. У чому різниця між stress test і load test?**
- **Load Test (Навантажувальне):** Емулює *реалістичне* навантаження (наприклад, 1000 користувачів, як у “Чорну п’ятницю”).
  - *Питання:* “Чи витримає система наших користувачів?”
- **Stress Test (Стрес-тестування):** Емулює *екстремальне* навантаження, що перевищує очікуване, доки система не впаде.
  - *Питання:* “При якому навантаженні система зламається і як саме вона це зробить (впаде вся чи просто сповільниться)?”
## <a name="x6951a665748cc17db5f82e8fe7c54fe300c19cb"></a>**4. Які інструменти використовують для тестування продуктивності?**
- **Apache JMeter:** Класичний інструмент на Java. Потужний, але має складний інтерфейс і споживає багато ресурсів.
- **k6:** Сучасний інструмент на Go. Сценарії пишуться на JavaScript. Легкий, швидкий, ідеальний для CI/CD.
- **Gatling:** Інструмент на Scala/Java. Використовує акторну модель для генерації величезного навантаження.
- **Locust:** Інструмент на Python. Сценарії пишуться кодом, легко масштабується.
- **Artillery:** Для тестування Node.js додатків.
## <a name="що-таке-масштабування-і-які-його-види"></a>**5. Що таке масштабування і які його види?**
**Масштабування (Scaling)** — це здатність системи обробляти збільшення навантаження шляхом додавання ресурсів.

**Види:** 1. **Вертикальне (Vertical Scaling / Scaling Up):** Збільшення потужності *одного* сервера (більше CPU, RAM, швидший диск). \* *Плюси:* Простота (не треба змінювати код). \* *Мінуси:* Є фізична межа, дорого, єдина точка відмови. 2. **Горизонтальне (Horizontal Scaling / Scaling Out):** Додавання *нових* серверів (вузлів) до кластера. \* *Плюси:* Теоретично нескінченне масштабування, дешевше, відмовостійкість. \* *Мінуси:* Складність адміністрування, необхідність адаптації архітектури (stateless).
## <a name="x19bacc5d632f13e3faae2b6981329d30bb021c2"></a>**6. Як визначити “вузьке місце” (bottleneck) у системі?**
Вузьке місце — це компонент, який обмежує загальну продуктивність системи. **Методи пошуку:** 1. **Навантажувальне тестування:** Поступово збільшувати навантаження і дивитися, який показник погіршується першим (Latency, Errors). 2. **Моніторинг ресурсів:** Дивитися на графіки (Grafana) під час тесту: \* Якщо CPU = 100% -> Вузьке місце в коді (обчислення). \* Якщо RAM = 100% -> Витік пам’яті або важкі процеси. \* Якщо Disk I/O високий -> Проблема в базі даних або логуванні. \* Якщо Network високий -> Пропускна здатність каналу. 3. **Профілювання (Profiling):** Аналіз коду (Flame graphs) для пошуку повільних функцій. 4. **Трасування (Tracing):** Аналіз ланцюжка запиту (Jaeger), щоб побачити, який саме мікросервіс або запит до БД гальмує відповідь.
## <a name="x8269bc97551abadab68392f535290f95cb4b36a"></a>**7. Як перевірити стійкість системи до відмов?**
- **Chaos Engineering (Хаос-інжиніринг):** Контрольоване введення збоїв у продакшн або стейджинг середовище.
  - *Інструмент:* **Chaos Mesh** або **Netflix Chaos Monkey**.
- **Сценарії перевірки:**
  - Вимкнути одну з нод Kubernetes (чи переїдуть поди?).
  - Вимкнути Master-базу даних (чи відбудеться перемикання на Replica?).
  - Додати затримку (latency) в мережу (чи спрацюють тайм-аути і Circuit Breaker?).
  - Заблокувати доступ до зовнішнього API (чи поверне система заглушку/помилку коректно?).

## **Список використаних джерел**
1. k6 Documentation - https://k6.io/docs/
1. Nginx Load Balancing - https://nginx.org/en/docs/http/load\_balancing.html
1. Docker Compose Documentation - https://docs.docker.com/compose/
1. “The Art of Scalability” - Martin L. Abbott, Michael T. Fisher
1. “Performance Testing Guidance” - Microsoft Patterns & Practices
1. “Load Balancing in the Cloud” - CloudFlare Documentation
1. Docker Swarm Documentation - https://docs.docker.com/engine/swarm/
1. PostgreSQL Performance Tuning - https://wiki.postgresql.org/wiki/Performance\_Optimization


