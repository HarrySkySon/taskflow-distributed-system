<a name="лабораторна-робота-5"></a>**КИЇВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ\
БУДІВНИЦТВА ТА АРХІТЕКТУРИ**\
\
\
Кафедра інформаційних технологій\
\
\
\
\
\
**ЛАБОРАТОРНА РОБОТА 5**\
\
з дисципліни

\
**"Архітектура розподілених програмних систем"**\
\
на тему:\
\
**"** **Розробка прототипу сервісу"**\
\
\

**\
\
\
\

**\
\


Виконав: студент групи ІПЗм(д)-25\
Постановський Ігор Анатолійович\
\
Перевірив: Мазуренко Р.В.

Київ – 2025
# **Звіт з лабораторної роботи №5**
<a name="аналіз-вимог-до-розподіленої-системи"></a>**Дисципліна:** Архітектура розподілених програмних систем 

**Тема:** Розробка прототипу сервісу
## <a name="розробка-прототипу-сервісу"></a><a name="мета-роботи"></a>**Мета роботи**
Метою лабораторної роботи є розробка прототипу мікросервісу з REST API, реалізація CRUD операцій для роботи з даними, налаштування підключення до бази даних PostgreSQL та контейнеризація сервісу за допомогою Docker.
## <a name="завдання"></a>**Завдання**
1. Обрати один із мікросервісів системи TaskFlow для реалізації прототипу
1. Розробити REST API з повним набором CRUD операцій
1. Реалізувати підключення до бази даних PostgreSQL
1. Створити схему бази даних з необхідними таблицями та індексами
1. Реалізувати контролери та маршрути для обробки HTTP запитів
1. Створити Dockerfile для контейнеризації сервісу
1. Налаштувати docker-compose.yml для оркестрації сервісу та бази даних
1. Протестувати API за допомогою Postman
1. Задокументувати всі endpoint’и та формати запитів/відповідей
## <a name="теоретичні-відомості"></a>**Теоретичні відомості**
### <a name="rest-api"></a>**REST API**
REST (Representational State Transfer) - архітектурний стиль для розробки веб-сервісів, що базується на використанні HTTP протоколу та його методів:

- **GET** - отримання ресурсу або колекції ресурсів
- **POST** - створення нового ресурсу
- **PUT/PATCH** - оновлення існуючого ресурсу
- **DELETE** - видалення ресурсу

Основні принципи REST: - Stateless (без стану) - кожен запит містить всю необхідну інформацію - Client-Server - розділення відповідальності між клієнтом та сервером - Cacheable - відповіді можуть кешуватися - Uniform Interface - єдиний інтерфейс взаємодії
### <a name="crud-операції"></a>**CRUD операції**
CRUD - базовий набір операцій для роботи з даними: - **Create** (Створити) - POST запит - **Read** (Прочитати) - GET запит - **Update** (Оновити) - PUT/PATCH запит - **Delete** (Видалити) - DELETE запит
### <a name="postgresql"></a>**PostgreSQL**
PostgreSQL - об’єктно-реляційна система управління базами даних з підтримкою ACID транзакцій, складних запитів, тригерів, представлень та процедур. Основні переваги: - Висока надійність та відповідність стандартам SQL - Підтримка JSON та повнотекстового пошуку - Розширюваність та масштабованість - Підтримка індексів для оптимізації запитів
### <a name="docker"></a>**Docker**
Docker - платформа для контейнеризації застосунків, що дозволяє: - Ізолювати застосунки та їх залежності - Забезпечити однакове середовище на різних машинах - Спростити розгортання та масштабування - Оркеструвати кілька контейнерів за допомогою Docker Compose
## <a name="опис-мікросервісу-projects-service"></a>**Опис мікросервісу Projects Service**
Для реалізації прототипу було обрано мікросервіс **Projects Service**, який є ключовим компонентом системи TaskFlow та відповідає за управління проєктами.
### <a name="функціональні-можливості"></a>**Функціональні можливості**
Projects Service надає наступний функціонал:

1. **Управління проєктами:**
   - Створення нових проєктів
   - Перегляд списку проєктів з фільтрацією та пагінацією
   - Отримання детальної інформації про проєкт
   - Оновлення параметрів проєкту
   - Видалення проєктів
1. **Управління учасниками:**
   - Додавання учасників до проєкту
   - Призначення ролей учасникам
   - Видалення учасників з проєкту
1. **Фільтрація та пошук:**
   - Фільтрація за власником проєкту
   - Фільтрація за статусом
   - Пагінація результатів
### <a name="технологічний-стек"></a>**Технологічний стек**
- **Runtime:** Node.js 20
- **Мова програмування:** TypeScript
- **Web-фреймворк:** Express.js
- **База даних:** PostgreSQL 16
- **ORM/Database driver:** pg (node-postgres)
- **Контейнеризація:** Docker + Docker Compose
##
## <a name="структура-проєкту"></a>**Структура проєкту**
Проєкт організовано за модульним принципом з розділенням відповідальності:

projects-service/\
├── src/\
│   ├── config/\
│   │   └── database.ts          # Конфігурація підключення до БД\
│   ├── controllers/\
│   │   └── project.controller.ts # Бізнес-логіка обробки запитів\
│   ├── models/\
│   │   └── project.model.ts      # Типи та інтерфейси даних\
│   ├── routes/\
│   │   └── project.routes.ts     # Визначення маршрутів API\
│   ├── middleware/\
│   │   └── errorHandler.ts       # Обробка помилок\
│   ├── app.ts                    # Налаштування Express застосунку\
│   └── server.ts                 # Точка входу\
├── package.json                  # Залежності проєкту\
├── tsconfig.json                 # Конфігурація TypeScript\
├── Dockerfile                    # Інструкції для збірки образу\
├── docker-compose.yml            # Оркестрація контейнерів\
├── .env.example                  # Приклад змінних середовища\
└── README.md                     # Документація проєкту
### <a name="опис-ключових-файлів"></a>**Опис ключових файлів**
#### <a name="database.ts"></a>*database.ts*
Відповідає за підключення до PostgreSQL, виконання запитів та ініціалізацію схеми бази даних. Використовує пул з’єднань для ефективного використання ресурсів.
#### <a name="project.controller.ts"></a>*project.controller.ts*
Містить клас ProjectController з методами для обробки всіх CRUD операцій. Кожен метод приймає об’єкти Request та Response з Express.
#### <a name="project.routes.ts"></a>*project.routes.ts*
Визначає маршрути API та зв’язує їх з відповідними методами контролера.
#### <a name="app.ts"></a>*app.ts*
Налаштовує Express застосунок: підключає middleware (CORS, JSON parser, логер), реєструє маршрути та обробники помилок.
#### <a name="server.ts"></a>*server.ts*
Ініціалізує базу даних та запускає HTTP сервер на вказаному порту.
##
## <a name="схема-бази-даних"></a>**Схема бази даних**
### <a name="таблиця-projects"></a>**Таблиця projects**
Основна таблиця для зберігання інформації про проєкти.

**CREATE** **TABLE** projects (\
`  `**id** SERIAL **PRIMARY** **KEY**,\
`  `name VARCHAR(200) **NOT** **NULL**,\
`  `description TEXT,\
`  `owner\_id INTEGER **NOT** **NULL**,\
`  `status VARCHAR(50) **DEFAULT** 'active',\
`  `start\_date DATE,\
`  `end\_date DATE,\
`  `deadline DATE,\
`  `priority VARCHAR(20) **DEFAULT** 'medium',\
`  `created\_at TIMESTAMP **DEFAULT** CURRENT\_TIMESTAMP,\
`  `updated\_at TIMESTAMP **DEFAULT** CURRENT\_TIMESTAMP\
);

**Поля:** - id - унікальний ідентифікатор проєкту (автоінкремент) - name - назва проєкту (обов’язкове поле) - description - опис проєкту - owner\_id - ідентифікатор власника проєкту - status - статус проєкту (active, completed, archived, on\_hold) - start\_date - дата початку проєкту - end\_date - фактична дата завершення - deadline - планова дата завершення - priority - пріоритет (low, medium, high, critical) - created\_at - дата створення запису - updated\_at - дата останнього оновлення
### <a name="таблиця-project_members"></a>**Таблиця project\_members**
Зберігає інформацію про учасників проєктів та їх ролі.

**CREATE** **TABLE** project\_members (\
`  `**id** SERIAL **PRIMARY** **KEY**,\
`  `project\_id INTEGER **NOT** **NULL** **REFERENCES** projects(**id**) **ON** **DELETE** **CASCADE**,\
`  `user\_id INTEGER **NOT** **NULL**,\
`  `**role** VARCHAR(50) **NOT** **NULL**,\
`  `joined\_at TIMESTAMP **DEFAULT** CURRENT\_TIMESTAMP,\
`  `**UNIQUE**(project\_id, user\_id)\
);

**Поля:** - id - унікальний ідентифікатор запису - project\_id - зовнішній ключ на таблицю projects - user\_id - ідентифікатор користувача - role - роль у проєкті (owner, manager, developer, designer, tester) - joined\_at - дата приєднання до проєкту

**Зв’язки:** - project\_id → projects.id (ON DELETE CASCADE) - Унікальне обмеження на пару (project\_id, user\_id)
### <a name="індекси"></a>**Індекси**
Для оптимізації запитів створено наступні індекси:

**CREATE** **INDEX** idx\_projects\_owner\_id **ON** projects(owner\_id);\
**CREATE** **INDEX** idx\_projects\_status **ON** projects(status);\
**CREATE** **INDEX** idx\_project\_members\_project\_id **ON** project\_members(project\_id);\
**CREATE** **INDEX** idx\_project\_members\_user\_id **ON** project\_members(user\_id);
##
## <a name="реалізація-rest-api"></a>**Реалізація REST API**
### <a name="архітектура-обробки-запитів"></a>**Архітектура обробки запитів**
HTTP Request\
`    `↓\
Express Router (routes/project.routes.ts)\
`    `↓\
Controller Method (controllers/project.controller.ts)\
`    `↓\
Database Query (config/database.ts)\
`    `↓\
PostgreSQL Database\
`    `↓\
Response JSON
### <a name="api-endpoints"></a>**API Endpoints**
#### <a name="health-check"></a>*1. Health Check*
**Endpoint:** GET /health

**Опис:** Перевірка стану сервісу

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Projects Service is running",\
`  `"timestamp": "2025-12-18T10:30:00.000Z"\
}
#### <a name="отримати-всі-проєкти"></a>*2. Отримати всі проєкти*
**Endpoint:** GET /api/projects

**Query параметри:** - owner\_id (optional) - фільтр за власником - status (optional) - фільтр за статусом - limit (optional, default: 50) - кількість записів - offset (optional, default: 0) - зсув для пагінації

**Приклад запиту:**

GET /api/projects?owner\_id=1&status=active&limit=10&offset=0

**Відповідь:**

{\
`  `"success": **true**,\
`  `"data": [\
`    `{\
`      `"id": 1,\
`      `"name": "TaskFlow Platform Development",\
`      `"description": "Розробка платформи управління проєктами",\
`      `"owner\_id": 1,\
`      `"status": "active",\
`      `"priority": "high",\
`      `"start\_date": "2025-01-01",\
`      `"deadline": "2025-06-30",\
`      `"created\_at": "2025-12-18T10:00:00.000Z",\
`      `"updated\_at": "2025-12-18T10:00:00.000Z"\
`    `}\
`  `],\
`  `"count": 1,\
`  `"limit": 10,\
`  `"offset": 0\
}
#### <a name="отримати-проєкт-за-id"></a>*3. Отримати проєкт за ID*
**Endpoint:** GET /api/projects/:id

**Query параметри:** - include\_members (optional) - включити список учасників

**Приклад запиту:**

GET /api/projects/1?include\_members=true

**Відповідь:**

{\
`  `"success": **true**,\
`  `"data": {\
`    `"id": 1,\
`    `"name": "TaskFlow Platform Development",\
`    `"description": "Розробка платформи управління проєктами",\
`    `"owner\_id": 1,\
`    `"status": "active",\
`    `"priority": "high",\
`    `"start\_date": "2025-01-01",\
`    `"deadline": "2025-06-30",\
`    `"created\_at": "2025-12-18T10:00:00.000Z",\
`    `"updated\_at": "2025-12-18T10:00:00.000Z",\
`    `"members": [\
`      `{\
`        `"id": 1,\
`        `"project\_id": 1,\
`        `"user\_id": 1,\
`        `"role": "owner",\
`        `"joined\_at": "2025-12-18T10:00:00.000Z"\
`      `}\
`    `]\
`  `}\
}
#### <a name="створити-проєкт"></a>*4. Створити проєкт*
**Endpoint:** POST /api/projects

**Тіло запиту:**

{\
`  `"name": "New Project",\
`  `"description": "Project description",\
`  `"owner\_id": 1,\
`  `"priority": "high",\
`  `"start\_date": "2025-01-01",\
`  `"deadline": "2025-12-31"\
}

**Обов’язкові поля:** - name - назва проєкту - owner\_id - ідентифікатор власника

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Project created successfully",\
`  `"data": {\
`    `"id": 2,\
`    `"name": "New Project",\
`    `"description": "Project description",\
`    `"owner\_id": 1,\
`    `"status": "active",\
`    `"priority": "high",\
`    `"start\_date": "2025-01-01",\
`    `"deadline": "2025-12-31",\
`    `"created\_at": "2025-12-18T10:30:00.000Z",\
`    `"updated\_at": "2025-12-18T10:30:00.000Z"\
`  `}\
}

**Примітка:** При створенні проєкту власник автоматично додається як учасник з роллю “owner”.
#### <a name="оновити-проєкт"></a>*5. Оновити проєкт*
**Endpoint:** PUT /api/projects/:id

**Тіло запиту:**

{\
`  `"status": "in\_progress",\
`  `"priority": "high",\
`  `"description": "Updated description"\
}

**Поля для оновлення (всі опціональні):** - name - назва - description - опис - status - статус - start\_date - дата початку - end\_date - дата завершення - deadline - дедлайн - priority - пріоритет

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Project updated successfully",\
`  `"data": {\
`    `"id": 1,\
`    `"name": "TaskFlow Platform Development",\
`    `"description": "Updated description",\
`    `"owner\_id": 1,\
`    `"status": "in\_progress",\
`    `"priority": "high",\
`    `"start\_date": "2025-01-01",\
`    `"deadline": "2025-06-30",\
`    `"created\_at": "2025-12-18T10:00:00.000Z",\
`    `"updated\_at": "2025-12-18T11:00:00.000Z"\
`  `}\
}
#### <a name="видалити-проєкт"></a>*6. Видалити проєкт*
**Endpoint:** DELETE /api/projects/:id

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Project deleted successfully"\
}

**Примітка:** При видаленні проєкту автоматично видаляються всі пов’язані записи з таблиці project\_members завдяки каскадному видаленню (ON DELETE CASCADE).
#### <a name="додати-учасника-до-проєкту"></a>*7. Додати учасника до проєкту*
**Endpoint:** POST /api/projects/:id/members

**Тіло запиту:**

{\
`  `"user\_id": 2,\
`  `"role": "developer"\
}

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Project member added successfully",\
`  `"data": {\
`    `"id": 2,\
`    `"project\_id": 1,\
`    `"user\_id": 2,\
`    `"role": "developer",\
`    `"joined\_at": "2025-12-18T11:30:00.000Z"\
`  `}\
}
#### <a name="видалити-учасника-з-проєкту"></a>*8. Видалити учасника з проєкту*
**Endpoint:** DELETE /api/projects/:id/members/:user\_id

**Відповідь:**

{\
`  `"success": **true**,\
`  `"message": "Project member removed successfully"\
}
### <a name="обробка-помилок"></a>**Обробка помилок**
Всі endpoint’и повертають стандартизовані відповіді з помилками:

**404 Not Found:**

{\
`  `"success": **false**,\
`  `"message": "Project not found"\
}

**400 Bad Request:**

{\
`  `"success": **false**,\
`  `"message": "Name and owner\_id are required"\
}

**500 Internal Server Error:**

{\
`  `"success": **false**,\
`  `"message": "Internal server error",\
`  `"error": "Detailed error message (only in development)"\
}
##
## <a name="контейнеризація-з-docker"></a>**Контейнеризація з Docker**
### <a name="dockerfile"></a>**Dockerfile**
Використано multi-stage build для оптимізації розміру образу:

*# Build stage*\
**FROM** node:20-alpine **AS** build\
**WORKDIR** /app\
**COPY** package\*.json ./\
**RUN** npm ci\
**COPY** . .\
**RUN** npm run build\
\
*# Production stage*\
**FROM** node:20-alpine\
**WORKDIR** /app\
**COPY** package\*.json ./\
**RUN** npm ci --only=production\
**COPY** --from=build /app/dist ./dist\
**RUN** addgroup -g 1001 -S nodejs **&&** \\
`    `adduser -S nodejs -u 1001\
**USER** nodejs\
**EXPOSE** 4002\
**HEALTHCHECK** --interval=30s --timeout=3s --start-period=5s --retries=3 \\
`  `**CMD** node -e "require('http').get('http://localhost:4002/health', ...)"\
**CMD** ["node", "dist/server.js"]

**Особливості:** 1. **Multi-stage build** - зменшує розмір фінального образу 2. **Alpine Linux** - мінімалістичний базовий образ 3. **Non-root user** - підвищує безпеку 4. **Health check** - перевіряє стан контейнера 5. **Production dependencies** - встановлюються лише робочі залежності
### <a name="docker-compose"></a>**Docker Compose**
Конфігурація для оркестрації сервісу та бази даних:

version**:** '3.8'\
\
services**:**\
`  `postgres**:**\
`    `image**:** postgres:16-alpine\
`    `container\_name**:** projects-db\
`    `environment**:**\
`      `POSTGRES\_DB**:** projects\_db\
`      `POSTGRES\_USER**:** postgres\
`      `POSTGRES\_PASSWORD**:** postgres\
`    `ports**:**\
`      `**-** "5432:5432"\
`    `volumes**:**\
`      `**-** postgres\_data:/var/lib/postgresql/data\
`    `healthcheck**:**\
`      `test**:** **[**"CMD-SHELL"**,** "pg\_isready -U postgres"**]**\
`      `interval**:** 10s\
`      `timeout**:** 5s\
`      `retries**:** 5\
`    `networks**:**\
`      `**-** projects-network\
\
`  `projects-service**:**\
`    `build**:**\
`      `context**:** .\
`      `dockerfile**:** Dockerfile\
`    `container\_name**:** projects-service\
`    `environment**:**\
`      `PORT**:** 4002\
`      `DB\_HOST**:** postgres\
`      `DB\_PORT**:** 5432\
`      `DB\_NAME**:** projects\_db\
`      `DB\_USER**:** postgres\
`      `DB\_PASSWORD**:** postgres\
`      `NODE\_ENV**:** production\
`    `ports**:**\
`      `**-** "4002:4002"\
`    `depends\_on**:**\
`      `postgres**:**\
`        `condition**:** service\_healthy\
`    `networks**:**\
`      `**-** projects-network\
`    `restart**:** unless-stopped\
\
volumes**:**\
`  `postgres\_data**:**\
`    `driver**:** local\
\
networks**:**\
`  `projects-network**:**\
`    `driver**:** bridge

**Особливості конфігурації:**

1. **Health check для PostgreSQL** - сервіс чекає на готовність БД
1. **Залежність сервісів** - Projects Service запускається після PostgreSQL
1. **Volumes** - дані PostgreSQL зберігаються на хості
1. **Network** - сервіси ізольовані в окремій мережі
1. **Restart policy** - автоматичний перезапуск при збоях
### <a name="команди-для-запуску"></a>**Команди для запуску**
*# Запустити всі сервіси*\
docker-compose up -d\
\
*# Переглянути логи*\
docker-compose logs -f\
\
*# Зупинити сервіси*\
docker-compose down\
\
*# Зупинити з видаленням volumes*\
docker-compose down -v
##
## <a name="тестування-api"></a>**Тестування API**
### <a name="postman-колекція"></a>**Postman колекція**
Для тестування API створено Postman колекцію з 8 запитами:

1. **Health Check** - перевірка стану сервісу
1. **Get All Projects** - отримання списку проєктів
1. **Get Project by ID** - отримання проєкту за ID
1. **Create Project** - створення нового проєкту
1. **Update Project** - оновлення проєкту
1. **Delete Project** - видалення проєкту
1. **Add Project Member** - додавання учасника
1. **Remove Project Member** - видалення учасника
### <a name="сценарій-тестування"></a>**Сценарій тестування**
#### <a name="крок-1-перевірка-health-check"></a>*Крок 1: Перевірка health check*
GET http://localhost:4002/health

**Очікуваний результат:** Статус 200, сервіс працює
#### <a name="крок-2-створення-проєкту"></a>*Крок 2: Створення проєкту*
POST http://localhost:4002/api/projects\
Content-Type: application/json\
\
{\
`  `"name": "TaskFlow Platform Development",\
`  `"description": "Розробка платформи управління проєктами TaskFlow",\
`  `"owner\_id": 1,\
`  `"priority": "high",\
`  `"start\_date": "2025-01-01",\
`  `"deadline": "2025-06-30"\
}

**Очікуваний результат:** Статус 201, проєкт створено з id=1
#### <a name="крок-3-отримання-всіх-проєктів"></a>*Крок 3: Отримання всіх проєктів*
GET http://localhost:4002/api/projects

**Очікуваний результат:** Статус 200, масив з 1 проєктом
#### <a name="x745fc81eca90d6625ae5bd320e9ffeea0999a8e"></a>*Крок 4: Отримання проєкту за ID з учасниками*
GET http://localhost:4002/api/projects/1?include\_members=true

**Очікуваний результат:** Статус 200, проєкт з масивом members (1 учасник - owner)
#### <a name="крок-5-додавання-учасника"></a>*Крок 5: Додавання учасника*
POST http://localhost:4002/api/projects/1/members\
Content-Type: application/json\
\
{\
`  `"user\_id": 2,\
`  `"role": "developer"\
}

**Очікуваний результат:** Статус 201, учасник доданий
#### <a name="крок-6-оновлення-проєкту"></a>*Крок 6: Оновлення проєкту*
PUT http://localhost:4002/api/projects/1\
Content-Type: application/json\
\
{\
`  `"status": "in\_progress",\
`  `"priority": "critical"\
}

**Очікуваний результат:** Статус 200, проєкт оновлено
#### <a name="крок-7-видалення-учасника"></a>*Крок 7: Видалення учасника*
DELETE http://localhost:4002/api/projects/1/members/2

**Очікуваний результат:** Статус 200, учасник видалений
#### <a name="крок-8-видалення-проєкту"></a>*Крок 8: Видалення проєкту*
DELETE http://localhost:4002/api/projects/1

**Очікуваний результат:** Статус 200, проєкт видалений
#### <a name="крок-9-перевірка-видалення"></a>*Крок 9: Перевірка видалення*
GET http://localhost:4002/api/projects/1

**Очікуваний результат:** Статус 404, проєкт не знайдено
### <a name="результати-тестування"></a>**Результати тестування**
Всі тести пройшли успішно:

|Тест|Метод|Endpoint|Статус|Результат|
| :- | :- | :- | :- | :- |
|Health Check|GET|/health|200|✓ Пройдено|
|Get All Projects|GET|/api/projects|200|✓ Пройдено|
|Get Project by ID|GET|/api/projects/:id|200|✓ Пройдено|
|Create Project|POST|/api/projects|201|✓ Пройдено|
|Update Project|PUT|/api/projects/:id|200|✓ Пройдено|
|Delete Project|DELETE|/api/projects/:id|200|✓ Пройдено|
|Add Member|POST|/api/projects/:id/members|201|✓ Пройдено|
|Remove Member|DELETE|/api/projects/:id/members/:user\_id|200|✓ Пройдено|
##
## <a name="висновки"></a>**Висновки**
В результаті виконання лабораторної роботи №5 було успішно розроблено прототип мікросервісу **Projects Service** для системи управління проєктами TaskFlow.
### <a name="досягнуті-результати"></a>**Досягнуті результати:**
1. **Реалізовано повний REST API** з 8 endpoint’ами для CRUD операцій над проєктами та управління учасниками
1. **Створено схему бази даних PostgreSQL** з двома таблицями (projects та project\_members), встановлено зв’язки та індекси для оптимізації запитів
1. **Розроблено модульну архітектуру** з чітким розділенням відповідальності:
   - Конфігурація БД
   - Моделі даних
   - Контролери бізнес-логіки
   - Маршрути API
   - Middleware для обробки помилок
1. **Реалізовано контейнеризацію** з використанням Docker multi-stage build для оптимізації розміру образу та підвищення безпеки
1. **Налаштовано Docker Compose** для оркестрації мікросервісу та бази даних з health checks та автоматичним перезапуском
1. **Створено Postman колекцію** для тестування всіх endpoint’ів API
1. **Задокументовано API** з детальним описом запитів, відповідей та форматів даних
### <a name="технічні-особливості-реалізації"></a>**Технічні особливості реалізації:**
- Використано TypeScript для типобезпеки
- Застосовано пул з’єднань для ефективної роботи з БД
- Реалізовано динамічні SQL запити з параметризацією
- Додано валідацію вхідних даних
- Створено стандартизовані формати відповідей
- Застосовано каскадне видалення для підтримки цілісності даних
### <a name="практична-цінність"></a>**Практична цінність:**
Розроблений прототип демонструє базові принципи побудови мікросервісів: - Незалежність та автономність сервісу - Чітко визначений API контракт - Ізоляція даних (власна база даних) - Можливість незалежного розгортання - Контейнеризація для портативності

Цей прототип може бути використаний як основа для реалізації повноцінного мікросервісу з додаванням: - Аутентифікації та авторизації (JWT) - Взаємодії з іншими мікросервісами через RabbitMQ - Логування та моніторингу - Кешування Redis - CI/CD pipeline
### <a name="отримані-навички"></a>**Отримані навички:**
- Проєктування REST API
- Робота з PostgreSQL та pg драйвером
- Розробка на Node.js + TypeScript + Express
- Контейнеризація з Docker
- Оркестрація з Docker Compose
- Тестування API з Postman
- Документування технічних рішень

Лабораторна робота виконана повністю, всі поставлені завдання реалізовані та протестовані.

**Відповіді на питання про REST та gRPC**

<a name="x9952de7de85fdee2f45daaadca4d33b64c10ff7"></a>**1. Що таке REST і які основні принципи RESTful API?**

**REST (Representational State Transfer)** — це архітектурний стиль для розробки розподілених систем, зокрема веб-сервісів. Він визначає набір обмежень, яких потрібно дотримуватися при створенні API.

**Основні принципи:** 

**Клієнт-сервер (Client-Server):** Чітке розділення обов’язків. Клієнт відповідає за інтерфейс користувача, сервер — за зберігання даних та бізнес-логіку. Це дозволяє розвивати їх незалежно. 

**Без стану (Stateless):** Сервер не зберігає інформацію про стан сесії клієнта між запитами. Кожен запит від клієнта повинен містити всю необхідну інформацію для його виконання (включаючи токени авторизації). 

**Кешування (Cacheable):** Відповіді сервера повинні явно вказувати, чи можна їх кешувати. Це дозволяє клієнту повторно використовувати дані та зменшити навантаження на мережу. 

**Єдиний інтерфейс (Uniform Interface):** Уніфікований спосіб взаємодії, що спрощує архітектуру. Включає ідентифікацію ресурсів (URI), маніпуляцію ресурсами через представлення та самоописові повідомлення. 

**Багаторівнева система (Layered System):** Клієнт не обов’язково знає, чи з’єднаний він напряму з кінцевим сервером, чи через посередників (балансувальники навантаження, проксі-сервери, шлюзи безпеки).

<a name="xdb5d78d9b5366cc9cc2fb033f0444def691557b"></a>**2. Які методи HTTP використовуються у REST API?**

Методи HTTP у REST зазвичай відповідають операціям CRUD (Create, Read, Update, Delete): 

**GET**: Використовується для отримання (читання) ресурсу. Є безпечним (не змінює стан) та ідемпотентним. 

**POST**: Використовується для створення нового ресурсу. Не є ідемпотентним (повторний запит створить дублікат). 

**PUT**: Використовується для повного оновлення або заміни існуючого ресурсу. Є ідемпотентним. 

**PATCH**: Використовується для часткового оновлення ресурсу (зміна лише окремих полів). 

**DELETE**: Використовується для видалення ресурсу. Є ідемпотентним.

**3. Чим gRPC відрізняється від REST?**

|Характеристика|REST|gRPC|
| :- | :- | :- |
|**Протокол**|HTTP/1.1 (текстовий, хоча може бути і HTTP/2)|HTTP/2 (бінарний, мультиплексування)|
|**Формат даних**|Переважно JSON (людино-читабельний)|Protocol Buffers (бінарний, компактний)|
|**Типізація**|Слабка (JSON схема опціональна)|Строга (контракт визначається у .proto файлах)|
|**Продуктивність**|Нижча (витрати на парсинг тексту, більший розмір повідомлень)|Висока (ефективна серіалізація, менший трафік)|
|**Комунікація**|Унарна (запит-відповідь)|Підтримка двонаправленого стрімінгу (Streaming)|
|**Генерація коду**|Потрібні сторонні інструменти (OpenAPI/Swagger)|Вбудована (protoc генерує клієнт і сервер)|
|**Основне застосування**|Публічні API, веб-додатки (браузери)|Внутрішня комунікація між мікросервісами|

<a name="чим-grpc-відрізняється-від-rest"></a>**4. Як описуються дані у gRPC?**

Дані та сервісні інтерфейси у gRPC описуються за допомогою мови опису інтерфейсів (IDL) — **Protocol Buffers (Protobuf)**. Опис зберігається у файлах з розширенням .proto.

**Приклад опису:**

syntax = "proto3";\
\
**message** User {\
`  `int32 id = 1;\
`  `string name = 2;\
`  `string email = 3;\
}\
\
service UserService {\
`  `rpc GetUser (UserRequest) returns (User);\
}

Кожне поле повідомлення має тип даних (наприклад, int32, string) та унікальний числовий тег (наприклад, = 1), який використовується для ідентифікації поля в бінарному потоці, що дозволяє зменшити розмір передаваних даних (не передаються назви полів).

<a name="як-описуються-дані-у-grpc"></a>**5. Що таке статус-коди HTTP?**

Статус-коди HTTP — це тризначні числа, які сервер надсилає у відповіді на HTTP-запит, щоб повідомити клієнту про результат виконання операції.

**Основні категорії:** 

**1xx (Informational):** Інформаційні коди (наприклад, 100 Continue). Запит отримано, процес триває. 

**2xx (Success):** Успіх (наприклад, 200 OK — все добре, 201 Created — ресурс створено). 

**3xx (Redirection):** Перенаправлення (наприклад, 301 Moved Permanently — ресурс переміщено назавжди, 304 Not Modified — дані не змінилися, візьми з кешу). 

**4xx (Client Error):** Помилка на боці клієнта (наприклад, 400 Bad Request — невірний запит, 401 Unauthorized — потрібна авторизація, 403 Forbidden — доступ заборонено, 404 Not Found — ресурс не знайдено). 

**5xx (Server Error):** Помилка на боці сервера (наприклад, 500 Internal Server Error — внутрішня помилка, 502 Bad Gateway, 503 Service Unavailable — сервіс недоступний).

<a name="що-таке-статус-коди-http"></a><a name="xdd9c4079e8c1b3082d1c3cf90b15242f178c720"></a>**6. Які інструменти використовують для тестування API?**

- **Postman**: Найпопулярніший інструмент з графічним інтерфейсом для розробки та тестування API. Дозволяє створювати колекції запитів, писати скрипти тестів.
- **Insomnia**: Потужний REST та GraphQL клієнт, більш мінімалістичний аналог Postman.
- **Swagger UI (OpenAPI)**: Дозволяє візуалізувати та взаємодіяти з API безпосередньо через браузер на основі специфікації.
- **cURL**: Інструмент командного рядка для передачі даних через URL. Часто використовується для швидких тестів або скриптів автоматизації.
- **JMeter / k6 / Gatling**: Інструменти для навантажувального тестування (Load Testing) та перевірки продуктивності API.

**7. Як забезпечити безпеку REST API?**

- **HTTPS (TLS/SSL):** Обов’язкове шифрування каналу передачі даних, щоб запобігти перехопленню (Man-in-the-Middle).
- **Аутентифікація (Authentication):** Перевірка особи користувача. Використання API Keys, Basic Auth або більш сучасних методів.
- **Авторизація (Authorization):** Перевірка прав доступу до конкретного ресурсу. Найпоширеніший стандарт — **OAuth 2.0** та використання **JWT (JSON Web Tokens)**.
- **Rate Limiting (Обмеження частоти запитів):** Захист від DDoS-атак та зловживань шляхом обмеження кількості запитів від одного клієнта за одиницю часу.
- **Валідація вхідних даних:** Перевірка всіх даних, що надходять від клієнта, щоб запобігти ін’єкціям (SQL Injection, XSS) та передачі некоректних даних.
- **CORS (Cross-Origin Resource Sharing):** Налаштування політики, яка дозволяє або забороняє браузерам робити запити до API з інших доменів.
- **Приховування деталей помилок:** Не повертати у відповідях <a name="як-забезпечити-безпеку-rest-api"></a><a name="відповіді-на-питання-про-rest-та-grpc"></a>500 стектрейси або деталі внутрішньої реалізації системи.

