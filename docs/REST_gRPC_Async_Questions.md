# Відповіді на питання про REST та gRPC

## 1. Що таке REST і які основні принципи RESTful API?
**REST (Representational State Transfer)** — це архітектурний стиль для розробки розподілених систем, зокрема веб-сервісів. Він визначає набір обмежень, яких потрібно дотримуватися при створенні API.

**Основні принципи:**
*   **Клієнт-сервер (Client-Server):** Чітке розділення обов'язків. Клієнт відповідає за інтерфейс користувача, сервер — за зберігання даних та бізнес-логіку. Це дозволяє розвивати їх незалежно.
*   **Без стану (Stateless):** Сервер не зберігає інформацію про стан сесії клієнта між запитами. Кожен запит від клієнта повинен містити всю необхідну інформацію для його виконання (включаючи токени авторизації).
*   **Кешування (Cacheable):** Відповіді сервера повинні явно вказувати, чи можна їх кешувати. Це дозволяє клієнту повторно використовувати дані та зменшити навантаження на мережу.
*   **Єдиний інтерфейс (Uniform Interface):** Уніфікований спосіб взаємодії, що спрощує архітектуру. Включає ідентифікацію ресурсів (URI), маніпуляцію ресурсами через представлення та самоописові повідомлення.
*   **Багаторівнева система (Layered System):** Клієнт не обов'язково знає, чи з'єднаний він напряму з кінцевим сервером, чи через посередників (балансувальники навантаження, проксі-сервери, шлюзи безпеки).

## 2. Які методи HTTP використовуються у REST API?
Методи HTTP у REST зазвичай відповідають операціям CRUD (Create, Read, Update, Delete):
*   **GET**: Використовується для отримання (читання) ресурсу. Є безпечним (не змінює стан) та ідемпотентним.
*   **POST**: Використовується для створення нового ресурсу. Не є ідемпотентним (повторний запит створить дублікат).
*   **PUT**: Використовується для повного оновлення або заміни існуючого ресурсу. Є ідемпотентним.
*   **PATCH**: Використовується для часткового оновлення ресурсу (зміна лише окремих полів).
*   **DELETE**: Використовується для видалення ресурсу. Є ідемпотентним.

## 3. Чим gRPC відрізняється від REST?
| Характеристика | REST | gRPC |
| :--- | :--- | :--- |
| **Протокол** | HTTP/1.1 (текстовий, хоча може бути і HTTP/2) | HTTP/2 (бінарний, мультиплексування) |
| **Формат даних** | Переважно JSON (людино-читабельний) | Protocol Buffers (бінарний, компактний) |
| **Типізація** | Слабка (JSON схема опціональна) | Строга (контракт визначається у .proto файлах) |
| **Продуктивність** | Нижча (витрати на парсинг тексту, більший розмір повідомлень) | Висока (ефективна серіалізація, менший трафік) |
| **Комунікація** | Унарна (запит-відповідь) | Підтримка двонаправленого стрімінгу (Streaming) |
| **Генерація коду** | Потрібні сторонні інструменти (OpenAPI/Swagger) | Вбудована (protoc генерує клієнт і сервер) |
| **Основне застосування** | Публічні API, веб-додатки (браузери) | Внутрішня комунікація між мікросервісами |

## 4. Як описуються дані у gRPC?
Дані та сервісні інтерфейси у gRPC описуються за допомогою мови опису інтерфейсів (IDL) — **Protocol Buffers (Protobuf)**. Опис зберігається у файлах з розширенням `.proto`.

**Приклад опису:**
```protobuf
syntax = "proto3";

message User {
  int32 id = 1;
  string name = 2;
  string email = 3;
}

service UserService {
  rpc GetUser (UserRequest) returns (User);
}
```
Кожне поле повідомлення має тип даних (наприклад, `int32`, `string`) та унікальний числовий тег (наприклад, `= 1`), який використовується для ідентифікації поля в бінарному потоці, що дозволяє зменшити розмір передаваних даних (не передаються назви полів).

## 5. Що таке статус-коди HTTP?
Статус-коди HTTP — це тризначні числа, які сервер надсилає у відповіді на HTTP-запит, щоб повідомити клієнту про результат виконання операції.

**Основні категорії:**
*   **1xx (Informational):** Інформаційні коди (наприклад, `100 Continue`). Запит отримано, процес триває.
*   **2xx (Success):** Успіх (наприклад, `200 OK` — все добре, `201 Created` — ресурс створено).
*   **3xx (Redirection):** Перенаправлення (наприклад, `301 Moved Permanently` — ресурс переміщено назавжди, `304 Not Modified` — дані не змінилися, візьми з кешу).
*   **4xx (Client Error):** Помилка на боці клієнта (наприклад, `400 Bad Request` — невірний запит, `401 Unauthorized` — потрібна авторизація, `403 Forbidden` — доступ заборонено, `404 Not Found` — ресурс не знайдено).
*   **5xx (Server Error):** Помилка на боці сервера (наприклад, `500 Internal Server Error` — внутрішня помилка, `502 Bad Gateway`, `503 Service Unavailable` — сервіс недоступний).

## 6. Які інструменти використовують для тестування API?
*   **Postman**: Найпопулярніший інструмент з графічним інтерфейсом для розробки та тестування API. Дозволяє створювати колекції запитів, писати скрипти тестів.
*   **Insomnia**: Потужний REST та GraphQL клієнт, більш мінімалістичний аналог Postman.
*   **Swagger UI (OpenAPI)**: Дозволяє візуалізувати та взаємодіяти з API безпосередньо через браузер на основі специфікації.
*   **cURL**: Інструмент командного рядка для передачі даних через URL. Часто використовується для швидких тестів або скриптів автоматизації.
*   **JMeter / k6 / Gatling**: Інструменти для навантажувального тестування (Load Testing) та перевірки продуктивності API.

## 7. Як забезпечити безпеку REST API?
*   **HTTPS (TLS/SSL):** Обов'язкове шифрування каналу передачі даних, щоб запобігти перехопленню (Man-in-the-Middle).
*   **Аутентифікація (Authentication):** Перевірка особи користувача. Використання API Keys, Basic Auth або більш сучасних методів.
*   **Авторизація (Authorization):** Перевірка прав доступу до конкретного ресурсу. Найпоширеніший стандарт — **OAuth 2.0** та використання **JWT (JSON Web Tokens)**.
*   **Rate Limiting (Обмеження частоти запитів):** Захист від DDoS-атак та зловживань шляхом обмеження кількості запитів від одного клієнта за одиницю часу.
*   **Валідація вхідних даних:** Перевірка всіх даних, що надходять від клієнта, щоб запобігти ін'єкціям (SQL Injection, XSS) та передачі некоректних даних.
*   **CORS (Cross-Origin Resource Sharing):** Налаштування політики, яка дозволяє або забороняє браузерам робити запити до API з інших доменів.
*   **Приховування деталей помилок:** Не повертати у відповідях `500` стектрейси або деталі внутрішньої реалізації системи.

## Відповіді на питання про Асинхронну взаємодію та Системи повідомлень

### 8. Що таке асинхронна взаємодія?
**Асинхронна взаємодія** — це спосіб комунікації між сервісами, при якому відправник надсилає запит (повідомлення) і не чекає миттєвої відповіді, продовжуючи свою роботу. Отримувач обробляє повідомлення у власному темпі.

**Ключові особливості:**
*   **Розв'язність (Decoupling):** Сервіси не знають про стан один одного (чи працює отримувач в даний момент).
*   **Буферизація:** Повідомлення можуть накопичуватися в черзі, якщо отримувач тимчасово недоступний або перевантажений.
*   **Покращення відгуку:** Клієнт отримує підтвердження "Запит прийнято" миттєво, не чекаючи завершення важкої операції.

### 9. Які системи повідомлень ви знаєте?
*   **RabbitMQ:** Найпопулярніший брокер повідомлень, що реалізує протокол AMQP. Надійний, гнучкий, підтримує складні сценарії маршрутизації.
*   **Apache Kafka:** Розподілена платформа потокової передачі подій. Орієнтована на високу пропускну здатність (мільйони повідомлень/сек) та зберігання історії подій (Log-based).
*   **ActiveMQ:** Класичний JMS-брокер від Apache.
*   **Redis Pub/Sub:** Легковаговий механізм підписки/публікації, але без гарантії доставки (повідомлення втрачаються, якщо немає підписників).
*   **Amazon SQS / SNS:** Хмарні сервіси черг та сповіщень від AWS.
*   **NATS:** Високопродуктивна система обміну повідомленнями для мікросервісів та IoT.

### 10. Як працює RabbitMQ?
RabbitMQ працює за схемою "Producer -> Exchange -> Queue -> Consumer".
1.  **Producer (Видавець):** Створює повідомлення і відправляє його в **Exchange** (Обмінник). Він ніколи не кладе повідомлення прямо в чергу.
2.  **Exchange:** Приймає повідомлення і вирішує, в яку чергу (або черги) його покласти, базуючись на правилах маршрутизації (Routing Key) та типі обмінника (Direct, Fanout, Topic, Headers).
3.  **Queue (Черга):** Буфер, де зберігаються повідомлення до моменту їх обробки.
4.  **Consumer (Споживач):** Підписується на чергу і забирає з неї повідомлення для обробки. Після успішної обробки надсилає підтвердження (Ack).

### 11. Що таке “publisher” і “subscriber”?
Це терміни з патерну **Pub/Sub (Publish-Subscribe)**:
*   **Publisher (Видавець):** Компонент, який генерує події (повідомлення) і відправляє їх у систему (наприклад, у Topic), не знаючи, хто саме їх отримає.
*   **Subscriber (Підписник):** Компонент, який виявляє інтерес до певного типу подій (підписується на Topic) і отримує їх, коли вони з'являються.
*   *Відмінність від черги:* У черзі повідомлення забирає лише один воркер. У Pub/Sub одне повідомлення копіюється всім активним підписникам.

### 12. У чому різниця між чергою та топіком?
*   **Черга (Queue) — Point-to-Point:**
    *   Повідомлення доставляється **тільки одному** споживачеві.
    *   Якщо споживачів кілька, вони конкурують за повідомлення (Load Balancing).
    *   Використовується для розподілу завдань (Work Queues).
*   **Топік (Topic) — Publish-Subscribe:**
    *   Повідомлення доставляється **всім** підписникам, які підписані на цей топік.
    *   Використовується для сповіщень, коли одна подія (наприклад, "Користувач зареєструвався") цікава багатьом сервісам (Email-сервіс, Аналітика, Бонусний сервіс).

### 13. Як обробляти помилки у подійно-орієнтованих системах?
Оскільки немає клієнта, який чекає відповіді, помилки не можна просто "повернути".
*   **Retry (Повтор):** Якщо помилка тимчасова (наприклад, БД недоступна), повідомлення повертається в чергу (Nack) для повторної спроби через деякий час.
*   **Dead Letter Queue (DLQ):** Якщо повідомлення не вдалося обробити після N спроб (або помилка критична, наприклад, невалідний JSON), воно переміщується в спеціальну чергу "мертвих листів" (DLQ).
*   **Моніторинг DLQ:** Розробники повинні налаштувати алерти на появу повідомлень у DLQ і розбирати їх вручну або виправляти баги.
*   **Idempotency:** Обробка повинна бути ідемпотентною, щоб повторна доставка повідомлення (дублікат) не призвела до некоректного стану системи.

### 14. Як тестувати міжсервісну взаємодію?
*   **Contract Testing (Pact):** Перевірка того, що сервіс-споживач і сервіс-провайдер дотримуються узгодженого контракту (формату запитів/відповідей), не піднімаючи реальні сервіси.
*   **Integration Testing:** Запуск групи сервісів (разом з БД та брокером повідомлень у Docker-контейнерах) і перевірка реальних сценаріїв взаємодії.
*   **End-to-End (E2E) Testing:** Тестування всієї системи як чорної скриньки від входу користувача до кінцевого результату.
*   **Tracing (Distributed Tracing):** Використання інструментів типу Jaeger або Zipkin для відстеження шляху запиту через усі мікросервіси, що допомагає знаходити вузькі місця та помилки інтеграції.
