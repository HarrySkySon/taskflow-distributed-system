# Звіт з лабораторної роботи №2
## Проєктування мікросервісної архітектури

**Дисципліна:** Архітектура розподілених програмних систем
**Тема:** Проєктування мікросервісної архітектури
**Мета:** Навчитися декомпозувати систему на мікросервіси

---

## 1. Теоретичні відомості

### 1.1 Мікросервісна архітектура

**Мікросервісна архітектура (microservice architecture)** — це підхід до проєктування програмних систем, у якому застосунок розділяється на низку незалежних сервісів, кожен з яких виконує одну чітку бізнес-функцію та взаємодіє з іншими через добре визначений інтерфейс (зазвичай REST або gRPC API).

### 1.2 Ключові принципи мікросервісів

**1. Single Responsibility Principle (Принцип єдиної відповідальності)**
- Кожен мікросервіс відповідає за одну бізнес-функцію
- Приклад: Users Service відповідає тільки за користувачів, Tasks Service — тільки за задачі

**2. Loose Coupling (Слабке зв'язування)**
- Мікросервіси мінімально залежать один від одного
- Зміни в одному сервісі не впливають на інші
- Взаємодія через добре визначені інтерфейси

**3. High Cohesion (Висока зв'язність)**
- Всі функції всередині сервісу тісно пов'язані між собою
- Приклад: в Tasks Service всі операції пов'язані з задачами

**4. Bounded Context (Обмежений контекст)**
- Кожен сервіс має власну модель даних
- Не дублює функціональність інших сервісів
- Чіткі межі відповідальності

**5. Database per Service (База даних на сервіс)**
- Кожен мікросервіс має власну базу даних
- Інші сервіси не мають прямого доступу до цієї БД
- Уникнення конфліктів при оновленнях

**6. Independent Deployment (Незалежне розгортання)**
- Сервіс може бути розгорнутий незалежно від інших
- Не потрібно зупиняти всю систему для оновлення

**7. Decentralized Data Management (Децентралізоване управління даними)**
- Кожен сервіс управляє своїми даними
- Немає єдиної центральної бази даних

### 1.3 Переваги мікросервісної архітектури

**✅ Масштабованість:**
- Можна масштабувати тільки потрібні сервіси
- Ефективніше використання ресурсів

**✅ Гнучкість технологій:**
- Різні сервіси можуть використовувати різні технології
- Можна вибрати найкращий інструмент для конкретної задачі

**✅ Незалежна розробка:**
- Різні команди можуть працювати над різними сервісами
- Паралельна розробка прискорює процес

**✅ Стійкість до відмов:**
- Збій одного сервісу не зупиняє всю систему
- Можливість graceful degradation

**✅ Легше оновлення:**
- Можна оновлювати сервіси незалежно
- Менший ризик при змінах

### 1.4 Недоліки мікросервісної архітектури

**❌ Складність:**
- Більше компонентів для управління
- Потрібна оркестрація (Kubernetes)
- Складніший моніторинг

**❌ Мережева взаємодія:**
- Додаткові затримки через мережу
- Потрібно обробляти помилки мережі

**❌ Узгодженість даних:**
- Складніше забезпечити транзакційність
- Потрібні розподілені транзакції або саги

**❌ Тестування:**
- Складніше тестувати взаємодію між сервісами
- Потрібні інтеграційні тести

**❌ Вищі вимоги до DevOps:**
- Потрібна автоматизація розгортання
- CI/CD пайплайни
- Контейнеризація

### 1.5 Відмінність від монолітної архітектури

| Характеристика | Моноліт | Мікросервіси |
|----------------|---------|--------------|
| **Структура** | Єдиний застосунок | Набір незалежних сервісів |
| **База даних** | Одна спільна БД | БД на кожен сервіс |
| **Розгортання** | Весь застосунок одразу | Кожен сервіс окремо |
| **Масштабування** | Тільки вертикальне | Горизонтальне по сервісах |
| **Технології** | Одна технологія | Різні технології |
| **Складність** | Простіше на старті | Складніше з самого початку |
| **Команда** | Одна команда | Декілька команд |

### 1.6 API Gateway

**API Gateway** — це єдина точка входу для всіх клієнтських запитів до мікросервісів.

**Функції API Gateway:**
- Маршрутизація запитів до відповідних сервісів
- Аутентифікація та авторизація
- Rate limiting (обмеження кількості запитів)
- Кешування відповідей
- Агрегація даних з кількох сервісів
- Трансформація запитів/відповідей
- Моніторинг та логування

**Популярні рішення:**
- Kong
- AWS API Gateway
- NGINX
- Traefik
- Custom (Node.js + Express)

### 1.7 Взаємодія між мікросервісами

**Синхронна взаємодія:**
- REST API (HTTP/HTTPS)
- gRPC (HTTP/2)
- Клієнт чекає на відповідь

**Асинхронна взаємодія:**
- Message Brokers (RabbitMQ, Kafka)
- Event-driven architecture
- Клієнт не чекає на відповідь

---

## 2. Завдання до роботи

Відповідно до методичних вказівок, необхідно:

1. Визначити 2-3 основних мікросервісів (у нашому випадку буде 6 мікросервісів)
2. Для кожного мікросервісу визначити:
   - Відповідальність (bounded context)
   - API endpoints
   - Структуру бази даних
   - Черги повідомлень
3. Побудувати Component Diagram або C4 Level 2

---

## 3. Протоколи розв'язання задач

### 3.1 Архітектурний огляд системи TaskFlow

Система TaskFlow складається з наступних компонентів:

```
┌─────────────────────────────────────────────────────────────────┐
│                          Web Browser                            │
│                      (React/Vue.js Client)                      │
└────────────────────────────┬────────────────────────────────────┘
                             │ HTTPS
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                         API Gateway                             │
│              (Kong / NGINX / Custom Node.js)                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │  Auth    │  │  Rate    │  │ Request  │  │  Cache   │      │
│  │Middleware│  │ Limiting │  │ Routing  │  │          │      │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘      │
└────────────┬──────────┬──────────┬──────────┬─────────────────┘
             │          │          │          │
    ┌────────┼──────────┼──────────┼──────────┼────────┐
    │        │          │          │          │        │
    ▼        ▼          ▼          ▼          ▼        ▼
┌────────┐┌────────┐┌────────┐┌────────┐┌────────┐┌────────┐
│ Users  ││Projects││ Tasks  ││Notific.││Analyt. ││Files   │
│Service ││Service ││Service ││Service ││Service ││Service │
└───┬────┘└───┬────┘└───┬────┘└───┬────┘└───┬────┘└────────┘
    │         │         │         │         │
    ▼         ▼         ▼         ▼         ▼
┌────────┐┌────────┐┌────────┐           ┌────────┐
│Users DB││Projects││Tasks DB│           │Analytics│
│        ││  DB    ││        │           │   DB    │
└────────┘└────────┘└────────┘           └────────┘
                             │
                             ▼
                     ┌──────────────┐
                     │  RabbitMQ    │
                     │Message Broker│
                     └──────────────┘
```

### 3.2 Детальний опис мікросервісів

---

## 3.2.1 API Gateway

### Відповідальність (Bounded Context):
- Єдина точка входу для всіх клієнтських запитів
- Маршрутизація до відповідних мікросервісів
- Аутентифікація та авторизація
- Rate limiting та захист від атак

### Технічний стек:
- **Технологія:** Node.js + Express або Kong
- **Порт:** 3000
- **Протокол:** HTTP/HTTPS

### Основні функції:

**1. Аутентифікація:**
- Перевірка JWT токенів
- Валідація access/refresh tokens
- Forwarding user context до сервісів

**2. Маршрутизація:**
- `/api/auth/*` → Users Service
- `/api/users/*` → Users Service
- `/api/projects/*` → Projects Service
- `/api/tasks/*` → Tasks Service
- `/api/analytics/*` → Analytics Service

**3. Rate Limiting:**
- Обмеження: 100 запитів/хвилину на IP
- Обмеження: 1000 запитів/хвилину на користувача

**4. Додаткові функції:**
- Request/Response logging
- CORS configuration
- Request transformation
- Response caching (опціонально)

### Конфігурація (приклад для Node.js):

```javascript
// api-gateway/src/routes.js
const routes = {
  '/api/auth': {
    target: 'http://users-service:4001',
    changeOrigin: true
  },
  '/api/users': {
    target: 'http://users-service:4001',
    changeOrigin: true,
    auth: true  // Requires authentication
  },
  '/api/projects': {
    target: 'http://projects-service:4002',
    changeOrigin: true,
    auth: true
  },
  '/api/tasks': {
    target: 'http://tasks-service:4003',
    changeOrigin: true,
    auth: true
  },
  '/api/notifications': {
    target: 'http://notifications-service:4004',
    changeOrigin: true,
    auth: true
  },
  '/api/analytics': {
    target: 'http://analytics-service:4005',
    changeOrigin: true,
    auth: true
  }
};
```

### Змінні оточення:

```env
PORT=3000
JWT_SECRET=your-secret-key
USERS_SERVICE_URL=http://users-service:4001
PROJECTS_SERVICE_URL=http://projects-service:4002
TASKS_SERVICE_URL=http://tasks-service:4003
NOTIFICATIONS_SERVICE_URL=http://notifications-service:4004
ANALYTICS_SERVICE_URL=http://analytics-service:4005
RATE_LIMIT_WINDOW=60000
RATE_LIMIT_MAX_REQUESTS=100
```

---

## 3.2.2 Users Service (Сервіс користувачів)

### Відповідальність (Bounded Context):
- Управління користувачами системи
- Реєстрація та аутентифікація
- Управління профілями
- Управління ролями та правами доступу

### Технічний стек:
- **Технологія:** Node.js + Express + TypeScript або Python + FastAPI
- **База даних:** PostgreSQL
- **Порт:** 4001
- **Протокол:** HTTP (внутрішня мережа)

### Структура бази даних:

```sql
-- Таблиця користувачів
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    avatar_url VARCHAR(500),
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця ролей
CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,  -- 'admin', 'manager', 'developer', 'observer'
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Зв'язок користувачів та ролей (Many-to-Many)
CREATE TABLE user_roles (
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id)
);

-- Таблиця refresh токенів
CREATE TABLE refresh_tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(500) UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Індекси для оптимізації
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(is_active);
CREATE INDEX idx_refresh_tokens_user ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);
```

### API Endpoints:

#### Аутентифікація:

**POST /api/auth/register**
- Реєстрація нового користувача
- Body: `{ email, password, firstName, lastName }`
- Response: `{ user, accessToken, refreshToken }`

**POST /api/auth/login**
- Вхід в систему
- Body: `{ email, password }`
- Response: `{ user, accessToken, refreshToken }`

**POST /api/auth/logout**
- Вихід з системи
- Headers: `Authorization: Bearer <token>`
- Response: `{ message: "Logged out successfully" }`

**POST /api/auth/refresh**
- Оновлення access token
- Body: `{ refreshToken }`
- Response: `{ accessToken, refreshToken }`

**POST /api/auth/verify-email**
- Підтвердження email
- Body: `{ token }`
- Response: `{ message: "Email verified" }`

**POST /api/auth/forgot-password**
- Запит на скидання паролю
- Body: `{ email }`
- Response: `{ message: "Reset email sent" }`

**POST /api/auth/reset-password**
- Скидання паролю
- Body: `{ token, newPassword }`
- Response: `{ message: "Password reset successfully" }`

#### Управління користувачами:

**GET /api/users**
- Отримання списку користувачів (з пагінацією)
- Query: `?page=1&limit=20&search=john&role=developer`
- Response: `{ users: [], total, page, limit }`

**GET /api/users/:id**
- Отримання користувача за ID
- Response: `{ id, email, firstName, lastName, roles, ... }`

**GET /api/users/me**
- Отримання профілю поточного користувача
- Headers: `Authorization: Bearer <token>`
- Response: `{ id, email, firstName, lastName, roles, ... }`

**PUT /api/users/me**
- Оновлення профілю поточного користувача
- Headers: `Authorization: Bearer <token>`
- Body: `{ firstName, lastName, avatarUrl }`
- Response: `{ user }`

**PUT /api/users/:id**
- Оновлення користувача (тільки admin)
- Body: `{ firstName, lastName, isActive }`
- Response: `{ user }`

**DELETE /api/users/:id**
- Видалення користувача (тільки admin)
- Response: `{ message: "User deleted" }`

#### Управління ролями:

**GET /api/users/:id/roles**
- Отримання ролей користувача
- Response: `{ roles: [] }`

**POST /api/users/:id/roles**
- Призначення ролі користувачу (тільки admin)
- Body: `{ roleId }`
- Response: `{ message: "Role assigned" }`

**DELETE /api/users/:id/roles/:roleId**
- Видалення ролі у користувача (тільки admin)
- Response: `{ message: "Role removed" }`

### Бізнес-логіка:

**Реєстрація користувача:**
1. Валідація даних (email, пароль)
2. Перевірка чи email вже існує
3. Хешування паролю (bcrypt)
4. Створення користувача в БД
5. Призначення ролі "developer" за замовчуванням
6. Генерація JWT токенів (access + refresh)
7. Відправка email для верифікації (через RabbitMQ)
8. Повернення токенів

**Аутентифікація:**
1. Пошук користувача за email
2. Перевірка паролю
3. Перевірка чи користувач активний
4. Генерація JWT токенів
5. Збереження refresh token в БД
6. Повернення токенів

**Оновлення токена:**
1. Валідація refresh token
2. Перевірка в БД
3. Перевірка терміну дії
4. Генерація нового access token
5. Ротація refresh token (створення нового)
6. Видалення старого refresh token
7. Повернення нових токенів

### Взаємодія з іншими сервісами:

**→ Notifications Service (асинхронно через RabbitMQ):**
- `user.registered` - подія реєстрації користувача
- `user.password_reset_requested` - запит на скидання паролю
- `user.email_verified` - email підтверджено

**← Projects Service, Tasks Service (синхронно через REST):**
- Запити для валідації користувачів
- Отримання інформації про користувачів

### Змінні оточення:

```env
PORT=4001
DB_HOST=users-db
DB_PORT=5432
DB_NAME=users_db
DB_USER=postgres
DB_PASSWORD=password
JWT_SECRET=your-jwt-secret
JWT_ACCESS_EXPIRATION=15m
JWT_REFRESH_EXPIRATION=7d
RABBITMQ_URL=amqp://rabbitmq:5672
BCRYPT_ROUNDS=10
```

---

## 3.2.3 Projects Service (Сервіс проєктів)

### Відповідальність (Bounded Context):
- Управління проєктами
- Управління командами проєктів
- Контроль доступу до проєктів

### Технічний стек:
- **Технологія:** Node.js + Express + TypeScript
- **База даних:** PostgreSQL
- **Порт:** 4002
- **Протокол:** HTTP

### Структура бази даних:

```sql
-- Таблиця проєктів
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    owner_id INTEGER NOT NULL,  -- ID користувача з Users Service
    status VARCHAR(50) DEFAULT 'active',  -- 'active', 'completed', 'suspended', 'archived'
    start_date DATE,
    end_date DATE,
    deadline DATE,
    priority VARCHAR(20) DEFAULT 'medium',  -- 'low', 'medium', 'high', 'critical'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця членів команди проєкту
CREATE TABLE project_members (
    id SERIAL PRIMARY KEY,
    project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL,  -- ID користувача з Users Service
    role VARCHAR(50) DEFAULT 'member',  -- 'owner', 'manager', 'member', 'observer'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Унікальний індекс щоб користувач не міг двічі бути в одному проєкті
CREATE UNIQUE INDEX idx_project_members_unique ON project_members(project_id, user_id);

-- Індекси для оптимізації
CREATE INDEX idx_projects_owner ON projects(owner_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_project_members_user ON project_members(user_id);
CREATE INDEX idx_project_members_project ON project_members(project_id);
```

### API Endpoints:

#### CRUD Операції для проєктів:

**GET /api/projects**
- Отримання списку проєктів (тільки ті, до яких користувач має доступ)
- Query: `?page=1&limit=20&status=active&search=name`
- Response: `{ projects: [], total, page, limit }`

**GET /api/projects/:id**
- Отримання проєкту за ID
- Response: `{ id, name, description, owner, members, tasks_count, ... }`

**POST /api/projects**
- Створення нового проєкту
- Body: `{ name, description, startDate, endDate, deadline, priority }`
- Response: `{ project }`

**PUT /api/projects/:id**
- Оновлення проєкту (тільки owner або manager)
- Body: `{ name, description, status, deadline, priority }`
- Response: `{ project }`

**DELETE /api/projects/:id**
- Видалення проєкту (тільки owner)
- Response: `{ message: "Project deleted" }`

#### Управління командою:

**GET /api/projects/:id/members**
- Отримання членів команди проєкту
- Response: `{ members: [{ userId, role, joinedAt, userInfo }] }`

**POST /api/projects/:id/members**
- Додавання члена команди (тільки owner або manager)
- Body: `{ userId, role }`
- Response: `{ message: "Member added" }`

**PUT /api/projects/:id/members/:userId**
- Зміна ролі члена команди (тільки owner)
- Body: `{ role }`
- Response: `{ message: "Role updated" }`

**DELETE /api/projects/:id/members/:userId**
- Видалення члена команди (тільки owner)
- Response: `{ message: "Member removed" }`

#### Статистика:

**GET /api/projects/:id/stats**
- Отримання статистики проєкту
- Response: `{ totalTasks, completedTasks, inProgressTasks, memberCount, progress }`

### Бізнес-логіка:

**Створення проєкту:**
1. Валідація даних
2. Створення проєкту в БД
3. Автоматичне додавання створювача як owner
4. Публікація події `project.created` (RabbitMQ)
5. Повернення створеного проєкту

**Додавання члена команди:**
1. Перевірка чи користувач має права (owner або manager)
2. Перевірка чи користувач вже є в команді
3. Валідація userId (запит до Users Service)
4. Додавання в БД
5. Публікація події `project.member_added` (RabbitMQ)
6. Відправка нотифікації новому члену

**Видалення проєкту:**
1. Перевірка прав (тільки owner)
2. Перевірка чи є активні задачі (запит до Tasks Service)
3. Архівування або видалення
4. Публікація події `project.deleted` (RabbitMQ)
5. Видалення всіх пов'язаних задач (через Tasks Service)

### Взаємодія з іншими сервісами:

**→ Users Service (синхронно через REST):**
- `GET /api/users/:id` - перевірка існування користувача
- `GET /api/users/batch` - отримання інфо про кількох користувачів

**→ Tasks Service (синхронно через REST):**
- `GET /api/tasks?projectId=:id` - отримання задач проєкту
- `DELETE /api/tasks?projectId=:id` - видалення всіх задач проєкту

**→ Notifications Service (асинхронно через RabbitMQ):**
- `project.created` - проєкт створено
- `project.updated` - проєкт оновлено
- `project.member_added` - додано нового члена команди
- `project.member_removed` - видалено члена команди
- `project.deadline_approaching` - наближається дедлайн

### Змінні оточення:

```env
PORT=4002
DB_HOST=projects-db
DB_PORT=5432
DB_NAME=projects_db
DB_USER=postgres
DB_PASSWORD=password
USERS_SERVICE_URL=http://users-service:4001
TASKS_SERVICE_URL=http://tasks-service:4003
RABBITMQ_URL=amqp://rabbitmq:5672
```

---

## 3.2.4 Tasks Service (Сервіс задач)

### Відповідальність (Bounded Context):
- Управління задачами
- Управління статусами та пріоритетами
- Коментарі до задач
- Прикріплення файлів до задач

### Технічний стек:
- **Технологія:** Node.js + Express + TypeScript
- **База даних:** PostgreSQL
- **Порт:** 4003
- **Протокол:** HTTP

### Структура бази даних:

```sql
-- Таблиця задач
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    project_id INTEGER NOT NULL,  -- ID проєкту з Projects Service
    title VARCHAR(300) NOT NULL,
    description TEXT,
    assignee_id INTEGER,  -- ID виконавця з Users Service (може бути NULL)
    reporter_id INTEGER NOT NULL,  -- ID створювача з Users Service
    status VARCHAR(50) DEFAULT 'new',  -- 'new', 'in_progress', 'in_review', 'completed', 'rejected'
    priority VARCHAR(20) DEFAULT 'medium',  -- 'low', 'medium', 'high', 'critical'
    due_date TIMESTAMP,
    estimated_hours DECIMAL(5,2),
    actual_hours DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);

-- Таблиця коментарів
CREATE TABLE task_comments (
    id SERIAL PRIMARY KEY,
    task_id INTEGER REFERENCES tasks(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL,  -- ID користувача з Users Service
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця файлів
CREATE TABLE task_attachments (
    id SERIAL PRIMARY KEY,
    task_id INTEGER REFERENCES tasks(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL,  -- ID користувача з Users Service
    filename VARCHAR(255) NOT NULL,
    file_url VARCHAR(500) NOT NULL,
    file_size INTEGER,  -- в байтах
    mime_type VARCHAR(100),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця історії змін статусів
CREATE TABLE task_status_history (
    id SERIAL PRIMARY KEY,
    task_id INTEGER REFERENCES tasks(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL,  -- ID користувача з Users Service
    old_status VARCHAR(50),
    new_status VARCHAR(50) NOT NULL,
    comment TEXT,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Індекси для оптимізації
CREATE INDEX idx_tasks_project ON tasks(project_id);
CREATE INDEX idx_tasks_assignee ON tasks(assignee_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_priority ON tasks(priority);
CREATE INDEX idx_task_comments_task ON task_comments(task_id);
CREATE INDEX idx_task_attachments_task ON task_attachments(task_id);
CREATE INDEX idx_task_status_history_task ON task_status_history(task_id);
```

### API Endpoints:

#### CRUD Операції для задач:

**GET /api/tasks**
- Отримання списку задач
- Query: `?projectId=1&assigneeId=5&status=in_progress&priority=high&page=1&limit=20`
- Response: `{ tasks: [], total, page, limit }`

**GET /api/tasks/:id**
- Отримання задачі за ID
- Response: `{ id, title, description, project, assignee, reporter, status, comments, attachments, ... }`

**POST /api/tasks**
- Створення нової задачі
- Body: `{ projectId, title, description, assigneeId, priority, dueDate, estimatedHours }`
- Response: `{ task }`

**PUT /api/tasks/:id**
- Оновлення задачі
- Body: `{ title, description, assigneeId, priority, dueDate, estimatedHours }`
- Response: `{ task }`

**DELETE /api/tasks/:id**
- Видалення задачі
- Response: `{ message: "Task deleted" }`

#### Управління статусами:

**PATCH /api/tasks/:id/status**
- Зміна статусу задачі
- Body: `{ status, comment }`
- Response: `{ task }`

**GET /api/tasks/:id/status-history**
- Отримання історії змін статусів
- Response: `{ history: [] }`

#### Коментарі:

**GET /api/tasks/:id/comments**
- Отримання коментарів задачі
- Response: `{ comments: [] }`

**POST /api/tasks/:id/comments**
- Додавання коментаря
- Body: `{ content }`
- Response: `{ comment }`

**PUT /api/tasks/:taskId/comments/:commentId**
- Редагування коментаря (тільки автор)
- Body: `{ content }`
- Response: `{ comment }`

**DELETE /api/tasks/:taskId/comments/:commentId**
- Видалення коментаря (тільки автор)
- Response: `{ message: "Comment deleted" }`

#### Файли:

**GET /api/tasks/:id/attachments**
- Отримання списку файлів
- Response: `{ attachments: [] }`

**POST /api/tasks/:id/attachments**
- Завантаження файлу
- Body: `multipart/form-data with file`
- Response: `{ attachment }`

**DELETE /api/tasks/:taskId/attachments/:attachmentId**
- Видалення файлу
- Response: `{ message: "Attachment deleted" }`

#### Час виконання:

**PATCH /api/tasks/:id/actual-hours**
- Вказання фактичного часу виконання
- Body: `{ actualHours }`
- Response: `{ task }`

### Бізнес-логіка:

**Створення задачі:**
1. Валідація даних
2. Перевірка чи проєкт існує (запит до Projects Service)
3. Перевірка чи користувач має доступ до проєкту
4. Перевірка чи assignee існує (запит до Users Service)
5. Створення задачі в БД
6. Публікація події `task.created` (RabbitMQ)
7. Відправка нотифікації призначеному виконавцю
8. Повернення створеної задачі

**Зміна статусу:**
1. Валідація переходу (new → in_progress → in_review → completed)
2. Перевірка прав користувача
3. Оновлення статусу в БД
4. Збереження в історію змін
5. Якщо статус "completed" - встановити completed_at
6. Публікація події `task.status_changed` (RabbitMQ)
7. Відправка нотифікації reporter та assignee

**Додавання коментаря:**
1. Валідація контенту
2. Перевірка доступу до задачі
3. Збереження коментаря в БД
4. Публікація події `task.commented` (RabbitMQ)
5. Відправка нотифікації згаданим користувачам (@mentions)

**Завантаження файлу:**
1. Валідація файлу (розмір ≤ 10 МБ)
2. Завантаження в File Storage (MinIO/S3)
3. Отримання URL файлу
4. Збереження метаданих в БД
5. Публікація події `task.attachment_added` (RabbitMQ)
6. Повернення інформації про файл

### Взаємодія з іншими сервісами:

**→ Projects Service (синхронно через REST):**
- `GET /api/projects/:id` - перевірка існування проєкту
- `GET /api/projects/:id/members` - перевірка доступу користувача

**→ Users Service (синхронно через REST):**
- `GET /api/users/:id` - перевірка існування користувача
- `GET /api/users/batch` - отримання інфо про кількох користувачів

**→ File Storage Service (синхронно через REST або S3 API):**
- `POST /upload` - завантаження файлу
- `DELETE /files/:id` - видалення файлу

**→ Notifications Service (асинхронно через RabbitMQ):**
- `task.created` - задача створена
- `task.updated` - задача оновлена
- `task.status_changed` - статус змінено
- `task.assigned` - задачу призначено виконавцю
- `task.commented` - додано коментар
- `task.due_soon` - наближається дедлайн

### Змінні оточення:

```env
PORT=4003
DB_HOST=tasks-db
DB_PORT=5432
DB_NAME=tasks_db
DB_USER=postgres
DB_PASSWORD=password
PROJECTS_SERVICE_URL=http://projects-service:4002
USERS_SERVICE_URL=http://users-service:4001
FILE_STORAGE_URL=http://file-storage:4006
RABBITMQ_URL=amqp://rabbitmq:5672
MAX_FILE_SIZE=10485760  # 10 MB in bytes
```

---

## 3.2.5 Notifications Service (Сервіс нотифікацій)

### Відповідальність (Bounded Context):
- Відправка email-повідомлень
- Управління in-app нотифікаціями
- Управління налаштуваннями нотифікацій користувачів

### Технічний стек:
- **Технологія:** Node.js + TypeScript або Python
- **База даних:** PostgreSQL (для зберігання нотифікацій та налаштувань)
- **Порт:** 4004
- **Протокол:** HTTP + RabbitMQ Consumer

### Структура бази даних:

```sql
-- Таблиця нотифікацій
CREATE TABLE notifications (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- ID користувача з Users Service
    type VARCHAR(50) NOT NULL,  -- 'task_assigned', 'task_completed', 'project_invite', etc.
    title VARCHAR(200) NOT NULL,
    message TEXT NOT NULL,
    related_entity_type VARCHAR(50),  -- 'task', 'project', 'comment'
    related_entity_id INTEGER,
    is_read BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця налаштувань нотифікацій
CREATE TABLE notification_preferences (
    user_id INTEGER PRIMARY KEY,  -- ID користувача з Users Service
    email_enabled BOOLEAN DEFAULT true,
    email_task_assigned BOOLEAN DEFAULT true,
    email_task_completed BOOLEAN DEFAULT true,
    email_task_commented BOOLEAN DEFAULT true,
    email_project_invite BOOLEAN DEFAULT true,
    email_deadline_reminder BOOLEAN DEFAULT true,
    in_app_enabled BOOLEAN DEFAULT true,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблиця відправлених email
CREATE TABLE sent_emails (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    recipient_email VARCHAR(255) NOT NULL,
    subject VARCHAR(300) NOT NULL,
    template VARCHAR(100),
    status VARCHAR(50) DEFAULT 'pending',  -- 'pending', 'sent', 'failed'
    error_message TEXT,
    sent_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Індекси
CREATE INDEX idx_notifications_user ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(is_read);
CREATE INDEX idx_notifications_created ON notifications(created_at DESC);
CREATE INDEX idx_sent_emails_user ON sent_emails(user_id);
CREATE INDEX idx_sent_emails_status ON sent_emails(status);
```

### API Endpoints:

#### In-app нотифікації:

**GET /api/notifications**
- Отримання нотифікацій поточного користувача
- Query: `?page=1&limit=20&unread=true`
- Response: `{ notifications: [], total, unreadCount }`

**GET /api/notifications/:id**
- Отримання нотифікації за ID
- Response: `{ notification }`

**PATCH /api/notifications/:id/read**
- Позначити нотифікацію як прочитану
- Response: `{ notification }`

**PATCH /api/notifications/read-all**
- Позначити всі нотифікації як прочитані
- Response: `{ message: "All notifications marked as read" }`

**DELETE /api/notifications/:id**
- Видалення нотифікації
- Response: `{ message: "Notification deleted" }`

#### Налаштування:

**GET /api/notifications/preferences**
- Отримання налаштувань нотифікацій
- Response: `{ preferences }`

**PUT /api/notifications/preferences**
- Оновлення налаштувань
- Body: `{ emailEnabled, emailTaskAssigned, inAppEnabled, ... }`
- Response: `{ preferences }`

### Обробка подій з RabbitMQ:

Сервіс підписується на наступні події:

#### Події від Users Service:
- `user.registered` → Send welcome email
- `user.email_verified` → Send confirmation email
- `user.password_reset_requested` → Send reset password email

#### Події від Projects Service:
- `project.created` → Notify team members
- `project.member_added` → Send invitation email + in-app notification
- `project.deadline_approaching` → Send reminder

#### Події від Tasks Service:
- `task.created` → Notify project manager
- `task.assigned` → Notify assignee
- `task.status_changed` → Notify reporter and assignee
- `task.commented` → Notify mentioned users
- `task.due_soon` → Send reminder

### Бізнес-логіка:

**Обробка події `task.assigned`:**
1. Отримання повідомлення з RabbitMQ
2. Парсинг даних (taskId, assigneeId, projectId)
3. Отримання налаштувань користувача з БД
4. Якщо email_enabled && email_task_assigned:
   - Отримання інфо про користувача (Users Service)
   - Отримання інфо про задачу (Tasks Service)
   - Рендеринг email шаблону
   - Відправка email через SMTP
   - Збереження запису в sent_emails
5. Якщо in_app_enabled:
   - Створення in-app нотифікації в БД
   - (Опціонально) Відправка через WebSocket для real-time

**Відправка email:**
```javascript
// Template example
const emailTemplate = {
  subject: `New task assigned: ${task.title}`,
  html: `
    <h2>You have been assigned a new task</h2>
    <p><strong>${task.title}</strong></p>
    <p>${task.description}</p>
    <p>Due date: ${task.dueDate}</p>
    <p>Priority: ${task.priority}</p>
    <a href="${appUrl}/tasks/${task.id}">View Task</a>
  `
};
```

### Взаємодія з іншими сервісами:

**→ Users Service (синхронно через REST):**
- `GET /api/users/:id` - отримання email та інфо користувача

**→ Tasks Service (синхронно через REST):**
- `GET /api/tasks/:id` - отримання деталей задачі для email

**→ Projects Service (синхронно через REST):**
- `GET /api/projects/:id` - отримання деталей проєкту

**← Всі сервіси (асинхронно через RabbitMQ):**
- Споживання подій

**→ External Email Service (SMTP):**
- Відправка email через SMTP (SendGrid, AWS SES, Mailgun, або власний SMTP)

### Змінні оточення:

```env
PORT=4004
DB_HOST=notifications-db
DB_PORT=5432
DB_NAME=notifications_db
DB_USER=postgres
DB_PASSWORD=password
RABBITMQ_URL=amqp://rabbitmq:5672
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-password
SMTP_FROM=TaskFlow <noreply@taskflow.com>
USERS_SERVICE_URL=http://users-service:4001
TASKS_SERVICE_URL=http://tasks-service:4003
PROJECTS_SERVICE_URL=http://projects-service:4002
APP_URL=https://taskflow.com
```

---

## 3.2.6 Analytics Service (Сервіс аналітики)

### Відповідальність (Bounded Context):
- Генерація звітів
- Статистика виконання задач
- Аналіз продуктивності команди
- Експорт даних (PDF, Excel)

### Технічний стек:
- **Технологія:** Python + FastAPI (для обробки даних) або Node.js
- **База даних:** PostgreSQL (read replica) або ClickHouse (для аналітики)
- **Порт:** 4005
- **Протокол:** HTTP

### Структура бази даних:

```sql
-- Таблиця агрегованих метрик проєктів (матеріалізована view або окрема таблиця)
CREATE TABLE project_metrics (
    id SERIAL PRIMARY KEY,
    project_id INTEGER NOT NULL,
    date DATE NOT NULL,
    total_tasks INTEGER DEFAULT 0,
    completed_tasks INTEGER DEFAULT 0,
    in_progress_tasks INTEGER DEFAULT 0,
    new_tasks INTEGER DEFAULT 0,
    rejected_tasks INTEGER DEFAULT 0,
    total_estimated_hours DECIMAL(10,2) DEFAULT 0,
    total_actual_hours DECIMAL(10,2) DEFAULT 0,
    active_members INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(project_id, date)
);

-- Таблиця метрик користувачів
CREATE TABLE user_metrics (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    date DATE NOT NULL,
    tasks_assigned INTEGER DEFAULT 0,
    tasks_completed INTEGER DEFAULT 0,
    total_hours DECIMAL(10,2) DEFAULT 0,
    comments_made INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, date)
);

-- Таблиця подій для аналітики (event sourcing)
CREATE TABLE analytics_events (
    id SERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50),  -- 'task', 'project', 'user'
    entity_id INTEGER,
    user_id INTEGER,
    project_id INTEGER,
    metadata JSONB,
    occurred_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Індекси
CREATE INDEX idx_project_metrics_project ON project_metrics(project_id);
CREATE INDEX idx_project_metrics_date ON project_metrics(date);
CREATE INDEX idx_user_metrics_user ON user_metrics(user_id);
CREATE INDEX idx_user_metrics_date ON user_metrics(date);
CREATE INDEX idx_analytics_events_type ON analytics_events(event_type);
CREATE INDEX idx_analytics_events_date ON analytics_events(occurred_at DESC);
```

### API Endpoints:

#### Статистика проєктів:

**GET /api/analytics/projects/:id/summary**
- Загальна статистика проєкту
- Response: `{ totalTasks, completedTasks, progress, estimatedVsActual, memberCount }`

**GET /api/analytics/projects/:id/timeline**
- Динаміка виконання задач по часу
- Query: `?startDate=2025-01-01&endDate=2025-12-31&groupBy=week`
- Response: `{ timeline: [{ date, completed, created, inProgress }] }`

**GET /api/analytics/projects/:id/burndown**
- Burndown chart для проєкту
- Response: `{ burndown: [{ date, remainingTasks, idealLine }] }`

**GET /api/analytics/projects/:id/velocity**
- Velocity chart (задачі виконані за спринт)
- Response: `{ velocity: [{ sprint, completed, points }] }`

#### Статистика користувачів:

**GET /api/analytics/users/:id/summary**
- Статистика користувача
- Response: `{ totalTasks, completedTasks, averageHours, productivity }`

**GET /api/analytics/users/:id/timeline**
- Динаміка роботи користувача
- Query: `?startDate=2025-01-01&endDate=2025-12-31`
- Response: `{ timeline: [{ date, completed, hours }] }`

**GET /api/analytics/users/:id/workload**
- Поточне навантаження користувача
- Response: `{ activeTasks, estimatedHours, upcomingDeadlines }`

#### Звіти:

**GET /api/analytics/reports/projects/:id**
- Генерація звіту по проєкту
- Query: `?format=pdf&startDate=2025-01-01&endDate=2025-12-31`
- Response: PDF або JSON

**GET /api/analytics/reports/team**
- Звіт по всій команді
- Query: `?format=excel&period=month`
- Response: Excel file або JSON

**GET /api/analytics/reports/user/:id**
- Персональний звіт користувача
- Response: JSON or PDF

#### Дашборди:

**GET /api/analytics/dashboard/overview**
- Загальний огляд системи
- Response: `{ totalProjects, totalTasks, activeUsers, systemLoad }`

**GET /api/analytics/dashboard/project/:id**
- Дашборд проєкту
- Response: `{ summary, timeline, members, recentActivity }`

### Бізнес-логіка:

**Генерація звіту по проєкту:**
1. Отримання даних проєкту (Projects Service)
2. Отримання всіх задач проєкту (Tasks Service)
3. Агрегація даних (completed, in_progress, total_hours)
4. Отримання інфо про членів команди (Users Service)
5. Розрахунок метрик (velocity, burndown, productivity)
6. Якщо format=pdf:
   - Рендеринг HTML template
   - Конвертація в PDF (puppeteer або wkhtmltopdf)
   - Повернення PDF файлу
7. Якщо format=excel:
   - Генерація Excel файлу (library: exceljs)
   - Повернення файлу
8. Інакше повернення JSON

**Обчислення burndown chart:**
1. Отримання дати початку та кінця проєкту
2. Отримання всіх задач з датами створення та завершення
3. Для кожної дати в діапазоні:
   - Підрахунок залишкових задач
   - Обчислення ідеальної лінії (лінійне зменшення)
4. Повернення масиву точок для графіка

**Обробка подій для аналітики:**
Сервіс підписується на події з RabbitMQ:
- `task.created` → Increment total_tasks
- `task.completed` → Increment completed_tasks, record hours
- `task.status_changed` → Update status counts
- `project.member_added` → Increment active_members

Події зберігаються в `analytics_events` для можливості replay/recompute.

### Взаємодія з іншими сервісами:

**→ Projects Service (синхронно через REST):**
- `GET /api/projects/:id` - отримання деталей проєкту
- `GET /api/projects/:id/members` - отримання команди

**→ Tasks Service (синхронно через REST):**
- `GET /api/tasks?projectId=:id` - отримання всіх задач проєкту
- `GET /api/tasks?assigneeId=:id` - отримання задач користувача

**→ Users Service (синхронно через REST):**
- `GET /api/users/batch` - отримання інфо про користувачів

**← Всі сервіси (асинхронно через RabbitMQ):**
- Споживання подій для побудови метрик

### Змінні оточення:

```env
PORT=4005
DB_HOST=analytics-db
DB_PORT=5432
DB_NAME=analytics_db
DB_USER=postgres
DB_PASSWORD=password
RABBITMQ_URL=amqp://rabbitmq:5672
USERS_SERVICE_URL=http://users-service:4001
PROJECTS_SERVICE_URL=http://projects-service:4002
TASKS_SERVICE_URL=http://tasks-service:4003
PDF_GENERATION_ENABLED=true
EXCEL_GENERATION_ENABLED=true
```

---

## 3.3 Component Diagram (C4 Level 2)

### PlantUML код:

```plantuml
@startuml TaskFlow_Component_Diagram
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title Component Diagram - TaskFlow System (C4 Level 2)

Person(user, "User", "Web Browser")
Person(admin, "Administrator", "System Admin")

System_Boundary(gateway, "API Gateway") {
    Component(auth_middleware, "Auth Middleware", "JWT Validation")
    Component(rate_limiter, "Rate Limiter", "Request Throttling")
    Component(router, "Router", "Request Routing")
}

System_Boundary(users, "Users Service") {
    Component(users_api, "Users API", "REST API", "Express.js")
    Component(users_auth, "Auth Module", "JWT Generation")
    Component(users_service, "Users Business Logic", "Registration, Login")
    ComponentDb(users_db, "Users Database", "PostgreSQL", "users, roles, tokens")
}

System_Boundary(projects, "Projects Service") {
    Component(projects_api, "Projects API", "REST API", "Express.js")
    Component(projects_service, "Projects Business Logic", "CRUD Projects")
    ComponentDb(projects_db, "Projects Database", "PostgreSQL", "projects, members")
}

System_Boundary(tasks, "Tasks Service") {
    Component(tasks_api, "Tasks API", "REST API", "Express.js")
    Component(tasks_service, "Tasks Business Logic", "CRUD Tasks")
    ComponentDb(tasks_db, "Tasks Database", "PostgreSQL", "tasks, comments, attachments")
}

System_Boundary(notifications, "Notifications Service") {
    Component(notifications_api, "Notifications API", "REST API", "Express.js")
    Component(notifications_consumer, "Event Consumer", "RabbitMQ Consumer")
    Component(email_sender, "Email Sender", "SMTP Client")
    ComponentDb(notifications_db, "Notifications DB", "PostgreSQL", "notifications, preferences")
}

System_Boundary(analytics, "Analytics Service") {
    Component(analytics_api, "Analytics API", "REST API", "FastAPI")
    Component(analytics_consumer, "Event Consumer", "RabbitMQ Consumer")
    Component(report_generator, "Report Generator", "PDF/Excel Generation")
    ComponentDb(analytics_db, "Analytics DB", "PostgreSQL", "metrics, events")
}

System_Ext(rabbitmq, "RabbitMQ", "Message Broker")
System_Ext(smtp, "SMTP Server", "Email Delivery")
System_Ext(storage, "File Storage", "MinIO/S3")

' User interactions
Rel(user, router, "HTTPS Requests", "JSON")
Rel(admin, router, "HTTPS Requests", "JSON")

' API Gateway routing
Rel(router, auth_middleware, "Validate Token")
Rel(router, rate_limiter, "Check Limits")
Rel(router, users_api, "Route /api/auth/*", "HTTP")
Rel(router, users_api, "Route /api/users/*", "HTTP")
Rel(router, projects_api, "Route /api/projects/*", "HTTP")
Rel(router, tasks_api, "Route /api/tasks/*", "HTTP")
Rel(router, notifications_api, "Route /api/notifications/*", "HTTP")
Rel(router, analytics_api, "Route /api/analytics/*", "HTTP")

' Users Service
Rel(users_api, users_service, "Business Logic")
Rel(users_service, users_auth, "Generate JWT")
Rel(users_service, users_db, "SQL Queries", "PostgreSQL")
Rel(users_service, rabbitmq, "Publish Events", "user.registered, user.verified")

' Projects Service
Rel(projects_api, projects_service, "Business Logic")
Rel(projects_service, projects_db, "SQL Queries", "PostgreSQL")
Rel(projects_service, users_api, "Validate Users", "HTTP")
Rel(projects_service, rabbitmq, "Publish Events", "project.created, member.added")

' Tasks Service
Rel(tasks_api, tasks_service, "Business Logic")
Rel(tasks_service, tasks_db, "SQL Queries", "PostgreSQL")
Rel(tasks_service, projects_api, "Validate Project", "HTTP")
Rel(tasks_service, users_api, "Validate Users", "HTTP")
Rel(tasks_service, storage, "Upload Files", "S3 API")
Rel(tasks_service, rabbitmq, "Publish Events", "task.created, task.assigned")

' Notifications Service
Rel(notifications_api, notifications_db, "SQL Queries", "PostgreSQL")
Rel(notifications_consumer, rabbitmq, "Consume Events", "AMQP")
Rel(notifications_consumer, email_sender, "Send Email")
Rel(email_sender, smtp, "SMTP Protocol")
Rel(notifications_consumer, users_api, "Get User Info", "HTTP")
Rel(notifications_consumer, notifications_db, "Store Notification")

' Analytics Service
Rel(analytics_api, analytics_db, "SQL Queries", "PostgreSQL")
Rel(analytics_api, report_generator, "Generate Report")
Rel(analytics_consumer, rabbitmq, "Consume Events", "AMQP")
Rel(analytics_consumer, analytics_db, "Store Metrics")
Rel(analytics_api, tasks_api, "Get Tasks Data", "HTTP")
Rel(analytics_api, projects_api, "Get Projects Data", "HTTP")
Rel(analytics_api, users_api, "Get Users Data", "HTTP")

@enduml
```

---

## 3.4 Взаємодія між мікросервісами (Sequence Diagram приклад)

### Приклад: Створення задачі та відправка нотифікації

```plantuml
@startuml Task_Creation_Sequence
actor User
participant "API Gateway" as Gateway
participant "Tasks Service" as Tasks
participant "Projects Service" as Projects
participant "Users Service" as Users
participant "RabbitMQ" as MQ
participant "Notifications Service" as Notifications
database "Tasks DB" as TasksDB

User -> Gateway: POST /api/tasks\n{projectId, title, assigneeId}
activate Gateway

Gateway -> Gateway: Validate JWT Token
Gateway -> Tasks: POST /tasks
activate Tasks

Tasks -> Projects: GET /projects/:projectId
activate Projects
Projects --> Tasks: {project details}
deactivate Projects

Tasks -> Users: GET /users/:assigneeId
activate Users
Users --> Tasks: {user details}
deactivate Users

Tasks -> TasksDB: INSERT task
activate TasksDB
TasksDB --> Tasks: {task created}
deactivate TasksDB

Tasks -> MQ: Publish event\n{task.created, task.assigned}
activate MQ
MQ --> Tasks: ACK
deactivate MQ

Tasks --> Gateway: {task}
deactivate Tasks

Gateway --> User: 201 Created\n{task}
deactivate Gateway

MQ -> Notifications: Consume event\n{task.assigned}
activate Notifications

Notifications -> Users: GET /users/:assigneeId
activate Users
Users --> Notifications: {user email}
deactivate Users

Notifications -> Notifications: Send Email\n"New task assigned"
Notifications -> Notifications: Create in-app notification

Notifications --> MQ: ACK
deactivate Notifications

@enduml
```

---

## 3.5 Технологічний стек (підсумок)

### Мікросервіси:

| Сервіс | Технологія | База даних | Порт |
|--------|-----------|-----------|------|
| **API Gateway** | Node.js + Express / Kong | - | 3000 |
| **Users Service** | Node.js + Express + TypeScript | PostgreSQL | 4001 |
| **Projects Service** | Node.js + Express + TypeScript | PostgreSQL | 4002 |
| **Tasks Service** | Node.js + Express + TypeScript | PostgreSQL | 4003 |
| **Notifications Service** | Node.js + TypeScript | PostgreSQL | 4004 |
| **Analytics Service** | Python + FastAPI / Node.js | PostgreSQL | 4005 |

### Інфраструктура:

- **Message Broker:** RabbitMQ (порт 5672, Management UI: 15672)
- **Databases:** PostgreSQL (окремі інстанси для кожного сервісу)
- **File Storage:** MinIO або AWS S3 (опціонально)
- **Cache:** Redis (майбутнє)

### DevOps:

- **Контейнеризація:** Docker
- **Оркестрація:** Docker Compose (розробка), Kubernetes (production)
- **CI/CD:** GitHub Actions
- **Моніторинг:** Prometheus + Grafana
- **Логування:** ELK Stack

---

## 4. Висновки

У ході виконання лабораторної роботи №2 було спроєктовано мікросервісну архітектуру для системи управління проєктами **TaskFlow**.

### Основні результати:

**1. Декомпозиція системи на мікросервіси:**
Систему розділено на 6 незалежних мікросервісів:
- API Gateway - маршрутизація та аутентифікація
- Users Service - управління користувачами
- Projects Service - управління проєктами
- Tasks Service - управління задачами
- Notifications Service - нотифікації
- Analytics Service - аналітика та звіти

**2. Визначено Bounded Context для кожного сервісу:**
Кожен мікросервіс має чітко визначену відповідальність і не дублює функціональність інших сервісів. Застосовано принцип Single Responsibility.

**3. Спроєктовано структуру баз даних:**
- Кожен сервіс має власну базу даних (Database per Service pattern)
- Розроблено схеми таблиць для кожного сервісу
- Додано індекси для оптимізації запитів
- Забезпечено можливість незалежного масштабування

**4. Визначено API endpoints:**
Для кожного сервісу розроблено REST API:
- Users Service: 15 endpoints (реєстрація, аутентифікація, управління профілями)
- Projects Service: 10 endpoints (CRUD проєктів, управління командою)
- Tasks Service: 16 endpoints (CRUD задач, коментарі, файли, статуси)
- Notifications Service: 7 endpoints (нотифікації, налаштування)
- Analytics Service: 11 endpoints (статистика, звіти, дашборди)

**5. Описано взаємодію між сервісами:**

**Синхронна взаємодія (REST API):**
- Projects Service → Users Service (валідація користувачів)
- Tasks Service → Projects Service (валідація проєктів)
- Tasks Service → Users Service (валідація користувачів)
- Analytics Service → всі сервіси (збір даних)
- Notifications Service → всі сервіси (отримання деталей для email)

**Асинхронна взаємодія (RabbitMQ):**
- Всі сервіси публікують події в RabbitMQ
- Notifications Service споживає події для відправки нотифікацій
- Analytics Service споживає події для побудови метрик
- Event-driven architecture забезпечує loose coupling

**6. Створено Component Diagram (C4 Level 2):**
Діаграма відображає:
- Всі компоненти кожного мікросервісу
- Взаємодію між компонентами
- Зовнішні залежності (RabbitMQ, SMTP, Storage)
- Потоки даних

**7. Визначено технологічний стек:**
- Backend: Node.js + Express + TypeScript
- Databases: PostgreSQL (окремі інстанси)
- Message Broker: RabbitMQ
- API Protocol: REST (HTTP/HTTPS)
- Асинхронна взаємодія: Event-driven через RabbitMQ

### Переваги спроєктованої архітектури:

✅ **Незалежність сервісів:**
- Кожен сервіс може розроблятись, тестуватись та розгортатись незалежно
- Різні команди можуть працювати паралельно

✅ **Масштабованість:**
- Можна масштабувати тільки потрібні сервіси
- Наприклад, Tasks Service можна масштабувати окремо від інших

✅ **Стійкість до відмов:**
- Збій одного сервісу не зупиняє всю систему
- Асинхронна взаємодія через RabbitMQ забезпечує надійність доставки

✅ **Гнучкість технологій:**
- Можна використовувати різні технології для різних сервісів
- Analytics Service може бути на Python, інші на Node.js

✅ **Слабке зв'язування (Loose Coupling):**
- Сервіси взаємодіють через добре визначені API
- Асинхронна взаємодія через події

### Потенційні проблеми та рішення:

**❌ Проблема: Узгодженість даних**
✅ Рішення:
- Event Sourcing для Analytics
- Eventual Consistency
- Saga Pattern для розподілених транзакцій (майбутнє)

**❌ Проблема: Мережеві затримки**
✅ Рішення:
- Кешування (Redis - майбутнє)
- Асинхронна взаємодія де можливо
- Оптимізація запитів

**❌ Проблема: Складність тестування**
✅ Рішення:
- Unit тести для кожного сервісу
- Integration тести для взаємодії
- Contract testing (Pact)

**❌ Проблема: Моніторинг розподіленої системи**
✅ Рішення:
- Centralized logging (ELK Stack)
- Distributed tracing (Jaeger - майбутнє)
- Metrics collection (Prometheus + Grafana)

### Практична цінність:

Спроєктована архітектура надає:
- Чіткий план реалізації системи
- Розуміння взаємодії між компонентами
- Основу для розгортання в Docker та Kubernetes
- Можливість поетапної розробки (спочатку Users + Projects + Tasks, потім Notifications + Analytics)

### Наступні кроки:

У наступних лабораторних роботах буде виконано:
- **ЛР №3:** Детальне моделювання взаємодії сервісів (Sequence Diagrams)
- **ЛР №4:** Розробка технологічної архітектури та Deployment Diagram
- **ЛР №5:** Практична реалізація одного з мікросервісів (Users Service)
- **ЛР №6:** Реалізація міжсервісної взаємодії через RabbitMQ
- **ЛР №7:** Оркестрація через Docker Compose та Kubernetes
- **ЛР №8:** Впровадження моніторингу (Prometheus + Grafana)
- **ЛР №9:** Тестування та масштабування

**Висновок:** Лабораторна робота №2 успішно виконана. Спроєктовано повноцінну мікросервісну архітектуру системи TaskFlow, що відповідає сучасним стандартам розробки розподілених систем та готова до практичної реалізації.

---

## Відповіді на контрольні запитання:

**1. Що таке мікросервісна архітектура?**

Мікросервісна архітектура — це підхід до проєктування програмних систем, у якому застосунок розділяється на низку незалежних сервісів, кожен з яких виконує одну чітку бізнес-функцію та взаємодіє з іншими через добре визначений інтерфейс (зазвичай REST або gRPC API). Кожен мікросервіс має власний життєвий цикл, базу даних і може розгортатися незалежно від інших компонентів системи.

**2. У чому відмінність моноліту від мікросервісів?**

| Характеристика | Моноліт | Мікросервіси |
|----------------|---------|--------------|
| Структура | Єдиний застосунок | Набір незалежних сервісів |
| База даних | Одна спільна БД | БД на кожен сервіс |
| Розгортання | Весь застосунок одразу | Кожен сервіс окремо |
| Масштабування | Тільки вертикальне | Горизонтальне по сервісах |
| Технології | Одна технологія | Різні технології |
| Складність | Простіше на старті | Складніше з самого початку |

**3. Які принципи проєктування мікросервісів ви знаєте?**

- **Single Responsibility** - одна відповідальність на сервіс
- **Loose Coupling** - слабке зв'язування між сервісами
- **High Cohesion** - висока зв'язність всередині сервісу
- **Bounded Context** - чіткі межі відповідальності
- **Database per Service** - окрема БД для кожного сервісу
- **Independent Deployment** - незалежне розгортання
- **Decentralized Data Management** - децентралізоване управління даними

**4. Як визначити межі сервісів (bounded context)?**

Bounded context визначається на основі:
1. **Бізнес-функціональності** - кожен сервіс відповідає за одну бізнес-функцію
2. **Domain-Driven Design** - виділення агрегатів та доменних моделей
3. **Команд ownership** - кожна команда відповідає за свій сервіс
4. **Незалежність змін** - зміни в одному сервісі не впливають на інші
5. **Масштабованість** - різні частини системи можуть мати різні вимоги до масштабування

У нашій системі:
- Users Service - все про користувачів і аутентифікацію
- Projects Service - все про проєкти та команди
- Tasks Service - все про задачі, коментарі, файли
- Notifications Service - все про нотифікації
- Analytics Service - все про аналітику та звіти

**5. Що таке API Gateway і навіщо він потрібен?**

API Gateway — це єдина точка входу для всіх клієнтських запитів до мікросервісів.

Функції:
- Маршрутизація запитів до відповідних сервісів
- Аутентифікація та авторизація (перевірка JWT)
- Rate limiting (захист від DDoS)
- Request/Response transformation
- Агрегація даних з кількох сервісів
- Caching
- Моніторинг та логування

Переваги:
- Спрощує клієнтську логіку (клієнт не знає про внутрішню структуру)
- Централізована безпека
- Зменшує кількість round-trips
- Легше змінювати внутрішню архітектуру без впливу на клієнтів

**6. Як забезпечується узгодженість даних між мікросервісами?**

Оскільки кожен мікросервіс має власну базу даних, узгодженість забезпечується через:

1. **Eventual Consistency (Евентуальна узгодженість)**
   - Дані стають узгодженими з часом
   - Використовується асинхронна взаємодія через події

2. **Event Sourcing**
   - Всі зміни зберігаються як послідовність подій
   - Analytics Service використовує цей підхід

3. **Saga Pattern**
   - Розподілені транзакції через послідовність локальних транзакцій
   - Якщо одна транзакція не вдалась - виконуються компенсаційні дії
   - Приклад: створення проєкту → додавання члена команди → створення задачі

4. **API Composition**
   - Агрегація даних з кількох сервісів на рівні API Gateway або окремого сервісу

5. **CQRS (Command Query Responsibility Segregation)**
   - Розділення операцій читання та запису
   - Analytics Service читає дані з read-only replica

У нашій системі:
- Асинхронні події через RabbitMQ для eventual consistency
- Event sourcing в Analytics Service
- API calls для синхронної валідації (Users Service, Projects Service)

**7. Які переваги та недоліки має мікросервісний підхід?**

**Переваги:**
✅ Масштабованість - можна масштабувати окремі сервіси
✅ Гнучкість технологій - різні технології для різних задач
✅ Незалежна розробка - паралельна робота команд
✅ Стійкість до відмов - fault isolation
✅ Легше оновлення - можна оновлювати частинами
✅ Кращий Time-to-market - швидше впровадження змін

**Недоліки:**
❌ Складність - більше компонентів для управління
❌ Мережева взаємодія - додаткові затримки
❌ Узгодженість даних - складніше забезпечити транзакційність
❌ Тестування - складніше інтеграційні тести
❌ DevOps complexity - потрібна автоматизація
❌ Моніторинг - складніше відстежувати всю систему
❌ Overhead - більше інфраструктурного коду

У нашій системі ми мінімізуємо недоліки через:
- Docker для спрощення розгортання
- RabbitMQ для надійної асинхронної взаємодії
- Prometheus + Grafana для моніторингу
- ELK Stack для централізованого логування

---

**Додатки:**

- Додаток А: PlantUML код для Component Diagram (C4 Level 2)
- Додаток Б: PlantUML код для Sequence Diagram
- Додаток В: Приклади SQL схем для кожного мікросервісу
- Додаток Г: Приклади API endpoints з request/response

**Корисні посилання:**
- Microservices Patterns: https://microservices.io/patterns/
- C4 Model: https://c4model.com/
- Domain-Driven Design: https://martinfowler.com/bliki/DomainDrivenDesign.html
- API Gateway Pattern: https://microservices.io/patterns/apigateway.html
- Database per Service: https://microservices.io/patterns/data/database-per-service.html
